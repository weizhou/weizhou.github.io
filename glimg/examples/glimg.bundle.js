!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var r=e();for(var n in r)("object"==typeof exports?exports:t)[n]=r[n]}}(window,(function(){return function(t){var e={};function r(n){if(e[n])return e[n].exports;var i=e[n]={i:n,l:!1,exports:{}};return t[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=t,r.c=e,r.d=function(t,e,n){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)r.d(n,i,function(e){return t[e]}.bind(null,i));return n},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=0)}([function(t,e,r){"use strict";r.r(e),r.d(e,"GLImgFilter",(function(){return n})),r.d(e,"GLImg3x3Filter",(function(){return i})),r.d(e,"GLImg3x3ConvFilter",(function(){return o})),r.d(e,"GLImgAverageColorFilter",(function(){return a})),r.d(e,"GLImgEmbossFilter",(function(){return u})),r.d(e,"GLImgMedianFilter",(function(){return s})),r.d(e,"GLImgSobelEdgeFilter",(function(){return h})),r.d(e,"GLImgGrayscaleFilter",(function(){return l})),r.d(e,"GLImage",(function(){return g}));class n{constructor(){this.vertexShader="\n      precision mediump float;\n\n      attribute vec3 inputPosition;\n      attribute vec2 inputTextureCoordinate;\n\n      uniform float flipY;\n    \n      varying vec2 textureCoordinate;\n\n      void main() {\n        gl_Position = vec4(inputPosition * vec3(1, flipY, 1), 1);\n        textureCoordinate = inputTextureCoordinate;\n      }\n    ",this.fragmentShader="\n      precision highp float;\n      varying vec2 textureCoordinate;\n      uniform sampler2D textureID;\n\n      void main() {\n        gl_FragColor = texture2D(textureID, textureCoordinate);\n      }\n    ",this.flipY=1}bindDataToAttribute(t,e,r,n,i){const o=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,o),t.bufferData(t.ARRAY_BUFFER,new Float32Array(n),t.STATIC_DRAW);const a=t.getAttribLocation(e,r);t.enableVertexAttribArray(a),t.bindBuffer(t.ARRAY_BUFFER,o),t.vertexAttribPointer(a,i,t.FLOAT,!1,0,0)}setUniformValue1i(t,e,r,n){const i=t.getUniformLocation(e,r);t.useProgram(e),t.uniform1i(i,n)}setUniformValue1f(t,e,r,n){const i=t.getUniformLocation(e,r);t.useProgram(e),t.uniform1f(i,n)}setUniformValue1fv(t,e,r,n){const i=t.getUniformLocation(e,r);t.useProgram(e),t.uniform1fv(i,n)}setUniformValue3fv(t,e,r,n){const i=t.getUniformLocation(e,r);t.useProgram(e),t.uniform3fv(i,n)}setUniformMatrix3fv(t,e,r,n){const i=t.getUniformLocation(e,r);t.useProgram(e),t.uniformMatrix3fv(i,!1,n)}bindShaderAttributes(t,e){this.bindDataToAttribute(t,e,"inputPosition",[-1,-1,0,1,-1,0,-1,1,0,1,1,0],3),this.bindDataToAttribute(t,e,"inputTextureCoordinate",[0,1,1,1,0,0,1,0],2),this.setUniformValue1f(t,e,"flipY",this.flipY),this.setUniformValue1i(t,e,"textureID",0)}}class i extends n{constructor(){super(),this.vertexShader="\n      attribute vec3 inputPosition;\n      attribute vec2 inputTextureCoordinate;\n      \n      uniform float texelWidth;\n      uniform float texelHeight; \n\n      uniform float flipY;\n      \n      varying vec2 textureCoordinate;\n      varying vec2 leftTextureCoordinate;\n      varying vec2 rightTextureCoordinate;\n      \n      varying vec2 topTextureCoordinate;\n      varying vec2 topLeftTextureCoordinate;\n      varying vec2 topRightTextureCoordinate;\n      \n      varying vec2 bottomTextureCoordinate;\n      varying vec2 bottomLeftTextureCoordinate;\n      varying vec2 bottomRightTextureCoordinate;\n      \n      void main()\n      {\n        gl_Position = vec4(inputPosition * vec3(1, flipY, 1), 1);\n        \n        vec2 widthStep = vec2(texelWidth, 0.0);\n        vec2 heightStep = vec2(0.0, texelHeight);\n        vec2 widthHeightStep = vec2(texelWidth, texelHeight);\n        vec2 widthNegativeHeightStep = vec2(texelWidth, -texelHeight);\n        \n        textureCoordinate = inputTextureCoordinate;\n        leftTextureCoordinate = inputTextureCoordinate - widthStep;\n        rightTextureCoordinate = inputTextureCoordinate + widthStep;\n        \n        topTextureCoordinate = inputTextureCoordinate - heightStep;\n        topLeftTextureCoordinate = inputTextureCoordinate - widthHeightStep;\n        topRightTextureCoordinate = inputTextureCoordinate + widthNegativeHeightStep;\n        \n        bottomTextureCoordinate = inputTextureCoordinate + heightStep;\n        bottomLeftTextureCoordinate = inputTextureCoordinate - widthNegativeHeightStep;\n        bottomRightTextureCoordinate = inputTextureCoordinate + widthHeightStep;\n      }\n    ",this.flipY=-1}bindShaderAttributes(t,e){super.bindShaderAttributes(t,e);const r=new Float32Array(this.convMatrix),n=1/t.canvas.width,i=1/t.canvas.height;this.setUniformValue1f(t,e,"texelWidth",n),this.setUniformValue1f(t,e,"texelHeight",i),this.setUniformMatrix3fv(t,e,"convolutionMatrix",r)}}class o extends i{constructor(){super(),this.fragmentShader="\n      precision highp float;\n\n      uniform sampler2D textureID;\n      \n      uniform mediump mat3 convolutionMatrix;\n      \n      varying vec2 textureCoordinate;\n      varying vec2 leftTextureCoordinate;\n      varying vec2 rightTextureCoordinate;\n      \n      varying vec2 topTextureCoordinate;\n      varying vec2 topLeftTextureCoordinate;\n      varying vec2 topRightTextureCoordinate;\n      \n      varying vec2 bottomTextureCoordinate;\n      varying vec2 bottomLeftTextureCoordinate;\n      varying vec2 bottomRightTextureCoordinate;\n      \n      void main()\n      {\n          mediump vec3 bottomColor = texture2D(textureID, bottomTextureCoordinate).rgb;\n          mediump vec3 bottomLeftColor = texture2D(textureID, bottomLeftTextureCoordinate).rgb;\n          mediump vec3 bottomRightColor = texture2D(textureID, bottomRightTextureCoordinate).rgb;\n          mediump vec4 centerColor = texture2D(textureID, textureCoordinate);\n          mediump vec3 leftColor = texture2D(textureID, leftTextureCoordinate).rgb;\n          mediump vec3 rightColor = texture2D(textureID, rightTextureCoordinate).rgb;\n          mediump vec3 topColor = texture2D(textureID, topTextureCoordinate).rgb;\n          mediump vec3 topRightColor = texture2D(textureID, topRightTextureCoordinate).rgb;\n          mediump vec3 topLeftColor = texture2D(textureID, topLeftTextureCoordinate).rgb;\n    \n          mediump vec3 resultColor = topLeftColor * convolutionMatrix[0][0] + topColor * convolutionMatrix[0][1] + topRightColor * convolutionMatrix[0][2];\n          resultColor += leftColor * convolutionMatrix[1][0] + centerColor.rgb * convolutionMatrix[1][1] + rightColor * convolutionMatrix[1][2];\n          resultColor += bottomLeftColor * convolutionMatrix[2][0] + bottomColor * convolutionMatrix[2][1] + bottomRightColor * convolutionMatrix[2][2];\n    \n          gl_FragColor = vec4(resultColor, centerColor.a);\n      }\n    ",this.convMatrix=[0,0,0,0,1,0,0,0,0]}bindShaderAttributes(t,e){super.bindShaderAttributes(t,e);const r=new Float32Array(this.convMatrix),n=1/t.canvas.width,i=1/t.canvas.height;this.setUniformValue1f(t,e,"texelWidth",n),this.setUniformValue1f(t,e,"texelHeight",i),this.setUniformMatrix3fv(t,e,"convolutionMatrix",r)}}class a extends i{constructor(){super(),this.fragmentShader="\n      precision highp float;\n      uniform sampler2D textureID;\n      \n      varying vec2 textureCoordinate;\n      varying vec2 leftTextureCoordinate;\n      varying vec2 rightTextureCoordinate;\n      \n      varying vec2 topTextureCoordinate;\n      varying vec2 topLeftTextureCoordinate;\n      varying vec2 topRightTextureCoordinate;\n      \n      varying vec2 bottomTextureCoordinate;\n      varying vec2 bottomLeftTextureCoordinate;\n      varying vec2 bottomRightTextureCoordinate;\n\n      \n      void main()\n      {\n          highp vec4 topLeftColor = texture2D(textureID, topLeftTextureCoordinate);\n          highp vec4 topRightColor = texture2D(textureID, topRightTextureCoordinate);\n          highp vec4 bottomLeftColor = texture2D(textureID, bottomLeftTextureCoordinate);\n          highp vec4 bottomRightColor = texture2D(textureID, bottomRightTextureCoordinate);\n          \n          gl_FragColor = 0.25 * (topLeftColor + topRightColor + bottomLeftColor + bottomRightColor);\n      }\n    "}}class u extends o{constructor(){super(),this.convMatrix=[-2,-1,0,-1,1,1,0,1,2]}}class s extends i{constructor(){super(),this.fragmentShader="\n\n        precision highp float;\n  \n        varying vec2 textureCoordinate;\n        varying vec2 leftTextureCoordinate;\n        varying vec2 rightTextureCoordinate;\n        \n        varying vec2 topTextureCoordinate;\n        varying vec2 topLeftTextureCoordinate;\n        varying vec2 topRightTextureCoordinate;\n        \n        varying vec2 bottomTextureCoordinate;\n        varying vec2 bottomLeftTextureCoordinate;\n        varying vec2 bottomRightTextureCoordinate;\n        \n        uniform sampler2D textureID;\n        \n        #define s2(a, b)\t\t\t\ttemp = a; a = min(a, b); b = max(temp, b);\n        #define mn3(a, b, c)\t\t\ts2(a, b); s2(a, c);\n        #define mx3(a, b, c)\t\t\ts2(b, c); s2(a, c);\n        \n        #define mnmx3(a, b, c)\t\t\tmx3(a, b, c); s2(a, b);                                   // 3 exchanges\n        #define mnmx4(a, b, c, d)\t\ts2(a, b); s2(c, d); s2(a, c); s2(b, d);                   // 4 exchanges\n        #define mnmx5(a, b, c, d, e)\ts2(a, b); s2(c, d); mn3(a, c, e); mx3(b, d, e);           // 6 exchanges\n        #define mnmx6(a, b, c, d, e, f) s2(a, d); s2(b, e); s2(c, f); mn3(a, b, c); mx3(d, e, f); // 7 exchanges\n      \n        void main()\n        {\n          vec3 v[6];\n    \n          v[0] = texture2D(textureID, bottomLeftTextureCoordinate).rgb;\n          v[1] = texture2D(textureID, topRightTextureCoordinate).rgb;\n          v[2] = texture2D(textureID, topLeftTextureCoordinate).rgb;\n          v[3] = texture2D(textureID, bottomRightTextureCoordinate).rgb;\n          v[4] = texture2D(textureID, leftTextureCoordinate).rgb;\n          v[5] = texture2D(textureID, rightTextureCoordinate).rgb;\n\n          vec3 temp;\n      \n          mnmx6(v[0], v[1], v[2], v[3], v[4], v[5]);\n          \n          v[5] = texture2D(textureID, bottomTextureCoordinate).rgb;\n                      \n          mnmx5(v[1], v[2], v[3], v[4], v[5]);\n                      \n          v[5] = texture2D(textureID, topTextureCoordinate).rgb;\n                                    \n          mnmx4(v[2], v[3], v[4], v[5]);\n                                    \n          v[5] = texture2D(textureID, textureCoordinate).rgb;\n                                                \n          mnmx3(v[3], v[4], v[5]);\n        \n          gl_FragColor = vec4(v[4], 1.0);\n        }\n      "}}class h extends o{constructor(){super(),this.convMatrix=[1,0,-1,2,0,-2,1,0,-1]}}class l extends n{constructor(){super(),this.fragmentShader="\n      precision highp float;\n      varying vec2 textureCoordinate;\n      uniform sampler2D textureID;\n      const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n  \n      void main()\n      {\n          lowp vec4 textureColor = texture2D(textureID, textureCoordinate);\n          float luminance = dot(textureColor.rgb, W);\n          \n          gl_FragColor = vec4(vec3(luminance), textureColor.a);\n      }\n    ",this.flipY=-1}}class g{constructor(){if(this._canvas=document.createElement("canvas"),this._gl=this._canvas.getContext("webgl2"),!this._gl)throw new Error("WebGL2 not supported");this._filters=[],this.defineUrlProperty()}addFilter(t){if(t.isAssembeFilter){var e=t.getAssemblingFilters();for(let t=0;t<e.length;++t)this.addFilter(e[t])}else this._filters.push(t)}defineUrlProperty(){Object.defineProperty(this,"url",{get(){return this._url},set(t){this._url=t;const e=new Image;e.onload=()=>{this.setupCanvasAndTexture(e),this.setupFilterChainTextureFrameBuffers(),this._gl.bindTexture(this._gl.TEXTURE_2D,this._texture);for(var t=0;t<this._filters.length;++t)this.drawTexture(this._filterChainFramebuffers[t%2],this._filterChainFramebufferTextures[t%2],this._filters[t]);var r=new n;this.drawTexture(null,null,r),this.onload()},e.src=t}})}setupCanvasAndTexture(t){this._canvas.width=t.width,this._canvas.height=t.height,this._gl.viewport(0,0,this._canvas.width,this._canvas.height);const e=this._gl.RGBA,r=this._gl.RGBA,n=this._gl.UNSIGNED_BYTE;this._texture=this._gl.createTexture(),this._gl.bindTexture(this._gl.TEXTURE_2D,this._texture),this._gl.texImage2D(this._gl.TEXTURE_2D,0,e,r,n,t),this._gl.generateMipmap(this._gl.TEXTURE_2D)}setupFilterChainTextureFrameBuffers(){this._filterChainFramebufferTextures=[],this._filterChainFramebuffers=[];for(let r=0;r<2;++r){var t=this._gl.createTexture();this._filterChainFramebufferTextures.push(t),this._gl.bindTexture(this._gl.TEXTURE_2D,t),this._gl.texImage2D(this._gl.TEXTURE_2D,0,this._gl.RGBA,this._canvas.width,this._canvas.height,0,this._gl.RGBA,this._gl.UNSIGNED_BYTE,null),this._gl.generateMipmap(this._gl.TEXTURE_2D);var e=this._gl.createFramebuffer();this._filterChainFramebuffers.push(e),this._gl.bindFramebuffer(this._gl.FRAMEBUFFER,e),this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER,this._gl.COLOR_ATTACHMENT0,this._gl.TEXTURE_2D,t,0)}}getImage(){var t=new Image;return t.src=this._canvas.toDataURL(),t}getCanvas(){return this._canvas}setupShader(t){this._activeVertexShader&&(this._gl.detachShader(this._glProgram,this._activeVertexShader),this._gl.deleteShader(this._activeVertexShader)),this._activeFragmentShader&&(this._gl.detachShader(this._glProgram,this._activeFragmentShader),this._gl.deleteShader(this._activeFragmentShader)),this._glProgram&&this._gl.deleteProgram(this._glProgram),this._glProgram=this._gl.createProgram();const e=this._gl.createShader(this._gl.VERTEX_SHADER);this._gl.shaderSource(e,t.vertexShader),this._gl.compileShader(e);const r=this._gl.createShader(this._gl.FRAGMENT_SHADER);this._gl.shaderSource(r,t.fragmentShader),this._gl.compileShader(r),this._activeVertexShader=e,this._gl.attachShader(this._glProgram,this._activeVertexShader),this._activeFragmentShader=r,this._gl.attachShader(this._glProgram,this._activeFragmentShader),this._gl.linkProgram(this._glProgram)}bindShaderAttributes(t){t.bindShaderAttributes(this._gl,this._glProgram)}drawTexture(t,e,r){this._gl.bindFramebuffer(this._gl.FRAMEBUFFER,t),this._gl.viewport(0,0,this._canvas.width,this._canvas.height),this.setupShader(r),this.bindShaderAttributes(r),this._gl.drawArrays(this._gl.TRIANGLE_STRIP,0,4),e&&this._gl.bindTexture(this._gl.TEXTURE_2D,e)}}g.prototype.onload=()=>{}}])}));