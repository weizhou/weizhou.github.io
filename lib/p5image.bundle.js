!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var n=t();for(var r in n)("object"==typeof exports?exports:e)[r]=n[r]}}(window,(function(){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=3)}([function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));class r{constructor(){this.vertexShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    attribute vec3 aPosition;\n    attribute vec2 aTexCoord;\n    uniform float flipY;\n    varying vec2 vTexCoord;\n    uniform float texelWidth;\n    uniform float texelHeight; \n    \n    void main() {\n      vec4 positionVec4 = vec4(aPosition * vec3(1.0, flipY, 1.0), 1.0);\n      positionVec4.xy = positionVec4.xy * 2.0 + vec2(-1.0, 1.0);\n      gl_Position = positionVec4;\n      vTexCoord = aTexCoord;\n    }\n    ",this.fragmentShader="\n    #ifdef GL_ES\n      precision mediump float;\n    #endif\n      \n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n\n    void main() {\n      gl_FragColor = texture2D(textureID, vTexCoord);\n    }\n    ",this.createShader=e=>{this.shader=e.createShader(this.vertexShader,this.fragmentShader)},this.apply=(e,t,n)=>{this.shader.setUniform("flipY",-1),this.shader.setUniform("texelWidth",1/n.w),this.shader.setUniform("texelHeight",1/n.h),this.shader.setUniform("textureID",e);for(const[e,t]of Object.entries(this.param))this.shader.setUniform(""+e,t);t.shader(this.shader),t.rect(0,0,1,1)}}}},function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,"a",(function(){return P5Img}));var _p5Filters_p5imgFilter__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(0);class P5Img{constructor(e){this.parentNode=e,this.init()}createFilters(filterStr){if(this.filters=[],null==filterStr){let e=new _p5Filters_p5imgFilter__WEBPACK_IMPORTED_MODULE_0__.a;return e.param={},void this.filters.push(e)}for(const[filterName,filterParams]of Object.entries(JSON.parse(filterStr))){null==filterParams.repeat&&(filterParams.repeat=1);for(let i=0;i<filterParams.repeat;i++){let filter=eval("new P5"+filterName+"()");filter.param=filterParams,this.filters.push(filter)}}}calculateSize(e,t){let n={};return null==e.w&&null==e.h?(n.w=t.w,n.h=t.h):null==e.w?(n.h=e.h,n.w=parseInt(n.h*(t.w/t.h))):null==e.h?(n.w=e.w,n.h=parseInt(n.w/(t.w/t.h))):(n.w=e.w,n.h=e.h),n}init(){this.count=0;this._p5=new p5(e=>{e.preload=()=>{this.img=e.loadImage(this.parentNode.src,()=>{})},e.setup=()=>{this.styleSize={};let t={};this.styleSize.w=this.parentNode.width,this.styleSize.h=this.parentNode.height,t.w=this.img.width,t.h=this.img.height,this.canvasSize=this.calculateSize(this.styleSize,t),this._canvas=e.createCanvas(this.canvasSize.w,this.canvasSize.h,e.WEBGL);let n=this._canvas.parent();this._canvas.parent(this.parentNode),n.remove(),this.createFilters(this.parentNode.filters),this.filters.forEach(t=>t.createShader(e)),e.noStroke()},e.draw=()=>{if(!(this.count>1)){this.count++;for(let t=0;t<this.filters.length;t++)this.filters[t].apply(0==t?this.img:e.get(),e,this.canvasSize)}}})}}},function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,"a",(function(){return P5ImgBlend}));class P5ImgBlend{constructor(e){this.parentNode=e,this.init()}createBlend(mode,param){let blender=eval("new P5"+mode+"()");this.blender=blender,this.blender.param=JSON.parse(param||"{}")}calculateSize(e,t){let n={};return null==e.w&&null==e.h?(n.w=t.w,n.h=t.h):null==e.w?(n.h=e.h,n.w=parseInt(n.h*(t.w/t.h))):null==e.h?(n.w=e.w,n.h=parseInt(n.w/(t.w/t.h))):(n.w=e.w,n.h=e.h),n}init(){this.count=0;this._p5=new p5(e=>{e.preload=()=>{this.img1=e.loadImage(this.parentNode.src1,()=>{}),this.img2=e.loadImage(this.parentNode.src2,()=>{})},e.setup=()=>{this.styleSize={};let t={};this.styleSize.w=this.parentNode.width,this.styleSize.h=this.parentNode.height,t.w=this.img1.width,t.h=this.img1.height,this.canvasSize=this.calculateSize(this.styleSize,t),this._canvas=e.createCanvas(this.canvasSize.w,this.canvasSize.h,e.WEBGL),this._canvas.parent(this.parentNode),this.createBlend(this.parentNode.mode,this.parentNode.param),this.blender.createShader(e),e.noStroke()},e.draw=()=>{this.count>1||(this.count++,this.blender.apply(e,this.img1,this.img2))}})}}},function(e,t,n){"use strict";n.r(t),n.d(t,"P5ImgFilter",(function(){return r.a})),n.d(t,"P5BrightnessFilter",(function(){return o})),n.d(t,"P5ChromakeyingFilter",(function(){return i})),n.d(t,"P5ColorInversionFilter",(function(){return a})),n.d(t,"P5ColormatrixFilter",(function(){return l})),n.d(t,"P5ContrastFilter",(function(){return s})),n.d(t,"P5ExposureFilter",(function(){return u})),n.d(t,"P5FalseColorFilter",(function(){return c})),n.d(t,"P5GammaFilter",(function(){return d})),n.d(t,"P5GrayscaleFilter",(function(){return x})),n.d(t,"P5HazeFilter",(function(){return m})),n.d(t,"P5HighlightShadowFilter",(function(){return v})),n.d(t,"P5HighlightShadowTintFilter",(function(){return f})),n.d(t,"P5HueFilter",(function(){return g})),n.d(t,"P5LevelsFilter",(function(){return h})),n.d(t,"P5LuminanceThresholdFilter",(function(){return p})),n.d(t,"P5MonochromeFilter",(function(){return C})),n.d(t,"P5OpacityFilter",(function(){return b})),n.d(t,"P5RGBFilter",(function(){return D})),n.d(t,"P5SaturationFilter",(function(){return y})),n.d(t,"P5SepiaToneFilter",(function(){return T})),n.d(t,"P5TemperatureFilter",(function(){return I})),n.d(t,"P5TintFilter",(function(){return S})),n.d(t,"P5VibranceFilter",(function(){return F})),n.d(t,"P5BlockFilter",(function(){return _})),n.d(t,"P5ConvFilter",(function(){return w})),n.d(t,"P5RadiusFilter",(function(){return L})),n.d(t,"P5AdaptiveThresholdFilter",(function(){return R})),n.d(t,"P5AverageColorFilter",(function(){return P})),n.d(t,"P5EmbossFilter",(function(){return W})),n.d(t,"P5BlockBlurFilter",(function(){return E})),n.d(t,"P5BoxBlurFilter",(function(){return G})),n.d(t,"P5GaussianBlurFilter",(function(){return A})),n.d(t,"P5MedianFilter",(function(){return B})),n.d(t,"P5SobelEdgeFilter",(function(){return k})),n.d(t,"P5NonMaximumSuppressionFilter",(function(){return M})),n.d(t,"P5WeakPixelInclusionFilter",(function(){return U})),n.d(t,"P5CannyEdgeFilter",(function(){return z})),n.d(t,"P5SharpenFilter",(function(){return H})),n.d(t,"P5CropFilter",(function(){return O})),n.d(t,"P5LanczosResamplingFilter",(function(){return j})),n.d(t,"P5BilateralBlurFilter",(function(){return V})),n.d(t,"P5MotionBlurFilter",(function(){return Y})),n.d(t,"P5ZoomBlurFilter",(function(){return N})),n.d(t,"P5TiltShiftFilter",(function(){return X})),n.d(t,"P5DilationFilter",(function(){return Q})),n.d(t,"P5ErosionFilter",(function(){return q})),n.d(t,"P5OpeningFilter",(function(){return $})),n.d(t,"P5ClosingFilter",(function(){return K})),n.d(t,"P5LocalBinaryPatternFilter",(function(){return J})),n.d(t,"P5ColorLocalBinaryPatternFilter",(function(){return Z})),n.d(t,"P5ColourFASTSamplingFilter",(function(){return ee})),n.d(t,"P5ColourFASTFeatureDetectorFilter",(function(){return te})),n.d(t,"P5PrewittEdgeFilter",(function(){return ne})),n.d(t,"P5XYDerivativeFilter",(function(){return re})),n.d(t,"P5HarrisCornerDetectionFilter",(function(){return oe})),n.d(t,"P5NobleCornerDetectionFilter",(function(){return ie})),n.d(t,"P5ShiTomasiFeatureDetectionFilter",(function(){return ae})),n.d(t,"P5PixellationFilter",(function(){return le})),n.d(t,"P5PolarPixellateFilter",(function(){return se})),n.d(t,"P5PolkaDotFilter",(function(){return ue})),n.d(t,"P5HalftoneFilter",(function(){return ce})),n.d(t,"P5CrosshatchFilter",(function(){return de})),n.d(t,"P5SketchFilter",(function(){return xe})),n.d(t,"P5ThresholdSketchFilter",(function(){return me})),n.d(t,"P5ToonFilter",(function(){return ve})),n.d(t,"P5SmoothToonFilter",(function(){return fe})),n.d(t,"P5PosterizeFilter",(function(){return ge})),n.d(t,"P5SwirlFilter",(function(){return he})),n.d(t,"P5BulgeFilter",(function(){return pe})),n.d(t,"P5PinchFilter",(function(){return Ce})),n.d(t,"P5StretchFilter",(function(){return be})),n.d(t,"P5SphereRefractionFilter",(function(){return De})),n.d(t,"P5GlassSphereRefractionFilter",(function(){return ye})),n.d(t,"P5VignetteFilter",(function(){return Te})),n.d(t,"P5KuwaharaFilter",(function(){return Ie})),n.d(t,"P5CGAColorSpaceFilter",(function(){return Se})),n.d(t,"P5SolarizeFilter",(function(){return Fe})),n.d(t,"P5Img",(function(){return _e.a})),n.d(t,"P5ImgElement",(function(){return we})),n.d(t,"P5Blender",(function(){return Le})),n.d(t,"P5AddBlender",(function(){return Re})),n.d(t,"P5MultiplyBlender",(function(){return Pe})),n.d(t,"P5ChromaKeyBlender",(function(){return We})),n.d(t,"P5SubtractBlender",(function(){return Ee})),n.d(t,"P5DivideBlender",(function(){return Ge})),n.d(t,"P5OverlayBlender",(function(){return Ae})),n.d(t,"P5DarkenBlender",(function(){return Be})),n.d(t,"P5LightenBlender",(function(){return ke})),n.d(t,"P5ColorBurnBlender",(function(){return Me})),n.d(t,"P5ColorDodgeBlender",(function(){return Ue})),n.d(t,"P5ScreenBlender",(function(){return ze})),n.d(t,"P5ExclusionBlender",(function(){return He})),n.d(t,"P5DifferenceBlender",(function(){return Oe})),n.d(t,"P5HardLightBlender",(function(){return je})),n.d(t,"P5SoftLightBlender",(function(){return Ve})),n.d(t,"P5AlphaBlender",(function(){return Ye})),n.d(t,"P5SourceOverBlender",(function(){return Ne})),n.d(t,"P5NormalBlender",(function(){return Xe})),n.d(t,"P5ColorBlender",(function(){return Qe})),n.d(t,"P5HueBlender",(function(){return qe})),n.d(t,"P5SaturationBlender",(function(){return $e})),n.d(t,"P5LuminosityBlender",(function(){return Ke})),n.d(t,"P5LinearBurnBlender",(function(){return Je})),n.d(t,"P5ImgBlend",(function(){return Ze.a})),n.d(t,"P5ImgBlendElement",(function(){return et}));var r=n(0);class o extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n    uniform lowp float brightness;\n\n    void main() {\n      vec4 textureColor = texture2D(textureID, vTexCoord);\n      gl_FragColor = vec4(textureColor.rgb+vec3(brightness), textureColor.a);\n    }\n    "}}class i extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n\n    uniform float thresholdSensitivity;\n    uniform float smoothing;\n    uniform vec3 colorToReplace;\n\n    void main() {\n      vec4 textureColor = texture2D(textureID, vTexCoord);\n\n      float maskY = 0.2989 * colorToReplace.r + 0.5866 * colorToReplace.g + 0.1145 * colorToReplace.b;\n      float maskCr = 0.7132 * (colorToReplace.r - maskY);\n      float maskCb = 0.5647 * (colorToReplace.b - maskY);\n      \n      float Y = 0.2989 * textureColor.r + 0.5866 * textureColor.g + 0.1145 * textureColor.b;\n      float Cr = 0.7132 * (textureColor.r - Y);\n      float Cb = 0.5647 * (textureColor.b - Y);\n\n      float blendValue = smoothstep(thresholdSensitivity, thresholdSensitivity + smoothing, distance(vec2(Cr, Cb), vec2(maskCr, maskCb)));\n      gl_FragColor = vec4(textureColor.rgb, textureColor.a * blendValue);\n    }\n    "}}class a extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n    uniform lowp float brightness;\n\n    void main() {\n      vec4 textureColor = texture2D(textureID, vTexCoord);\n      gl_FragColor = vec4((1.0 - textureColor.rgb), textureColor.a);\n    }\n    "}}class l extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n    uniform mat4 colorMatrix;\n    uniform float intensity;\n\n    void main() {\n      lowp vec4 textureColor = texture2D(textureID, vTexCoord);\n      lowp vec4 outputColor = textureColor * colorMatrix;        \n      gl_FragColor = (intensity * outputColor) + ((1.0 - intensity) * textureColor);\n    }\n    "}}class s extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n    \n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n    uniform float contrast;\n    \n    void main() {\n      vec4 textureColor = texture2D(textureID, vTexCoord);\n      gl_FragColor = vec4(((textureColor.rgb - vec3(0.5)) * contrast + vec3(0.5)), textureColor.a);\n    } "}}class u extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n    uniform float exposure;\n\n    void main() {\n      vec4 textureColor = texture2D(textureID, vTexCoord);\n      gl_FragColor = vec4(textureColor.rgb * pow(2.0, exposure), textureColor.a);\n\n    }\n    "}}class c extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n    uniform vec3 firstColor;\n    uniform vec3 secondColor;\n\n    const vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n\n    void main() {\n      vec4 textureColor = texture2D(textureID, vTexCoord);\n      float luminance = dot(textureColor.rgb, luminanceWeighting);      \n      gl_FragColor = vec4( mix(firstColor.rgb, secondColor.rgb, luminance), textureColor.a);\n    }\n    "}}class d extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n    uniform float gamma;\n\n    void main()\n    {\n        vec4 textureColor = texture2D(textureID, vTexCoord);        \n        gl_FragColor = vec4(pow(textureColor.rgb, vec3(gamma)), textureColor.a);\n      }\n    "}}class x extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n    const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n\n    void main()\n    {\n        vec4 textureColor = texture2D(textureID, vTexCoord);\n        float luminance = dot(textureColor.rgb, W);\n        \n        gl_FragColor = vec4(vec3(luminance), textureColor.a);\n    }\n    "}}class m extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n    uniform float hazeDistance;\n    uniform float slope;\n\n    void main() {\n      vec4 textureColor = texture2D(textureID, vTexCoord);\n\n      float  d = vTexCoord.y * slope  +  hazeDistance;            \n      vec4 c = (textureColor - d) / (1.0 - d);\n      \n      gl_FragColor = c; \n    }\n    "}}class v extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n    uniform float shadows;\n    uniform float highlights;\n\n    const mediump vec3 luminanceWeighting = vec3(0.3, 0.3, 0.3);\n\n    void main() {\n      vec4 textureColor = texture2D(textureID, vTexCoord);\n\n      float luminance = dot(textureColor.rgb, luminanceWeighting);\n  \n      float shadow = clamp((pow(luminance, 1.0/(shadows+1.0)) + (-0.76)*pow(luminance, 2.0/(shadows+1.0))) - luminance, 0.0, 1.0);\n      float highlight = clamp((1.0 - (pow(1.0-luminance, 1.0/(2.0-highlights)) + (-0.8)*pow(1.0-luminance, 2.0/(2.0-highlights)))) - luminance, -1.0, 0.0);\n      vec3 result = vec3(0.0, 0.0, 0.0) + ((luminance + shadow + highlight) - 0.0) * ((textureColor.rgb - vec3(0.0, 0.0, 0.0))/(luminance - 0.0));\n    \n      gl_FragColor = vec4(result, textureColor.a);\n      \n    }\n    "}}class f extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n    uniform float shadowTintIntensity;\n    uniform float highlightTintIntensity;\n    uniform vec3 shadowTintColor;\n    uniform vec3 highlightTintColor;\n\n    const vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n\n    void main() {\n      vec4 textureColor = texture2D(textureID, vTexCoord);\n\n      float luminance = dot(textureColor.rgb, luminanceWeighting);\n      \n      highp vec4 shadowResult = mix(textureColor, max(textureColor, vec4( mix(shadowTintColor, textureColor.rgb, luminance), textureColor.a)), shadowTintIntensity);\n      highp vec4 highlightResult = mix(textureColor, min(shadowResult, vec4( mix(shadowResult.rgb, highlightTintColor, luminance), textureColor.a)), highlightTintIntensity);\n  \n      gl_FragColor = vec4( mix(shadowResult.rgb, highlightResult.rgb, luminance), textureColor.a);     \n    }\n    "}}class g extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n    uniform float hueAdjust;\n\n    const vec4  kRGBToYPrime = vec4 (0.299, 0.587, 0.114, 0.0);\n    const vec4  kRGBToI     = vec4 (0.595716, -0.274453, -0.321263, 0.0);\n    const vec4  kRGBToQ     = vec4 (0.211456, -0.522591, 0.31135, 0.0);\n    \n    const vec4  kYIQToR   = vec4 (1.0, 0.9563, 0.6210, 0.0);\n    const vec4  kYIQToG   = vec4 (1.0, -0.2721, -0.6474, 0.0);\n    const vec4  kYIQToB   = vec4 (1.0, -1.1070, 1.7046, 0.0);\n  \n\n    void main() {\n      vec4 textureColor = texture2D(textureID, vTexCoord);\n\n      // Convert to YIQ\n      highp float   YPrime  = dot (textureColor, kRGBToYPrime);\n      highp float   I      = dot (textureColor, kRGBToI);\n      highp float   Q      = dot (textureColor, kRGBToQ);\n      \n      // Calculate the hue and chroma\n      highp float   hue     = atan (Q, I);\n      highp float   chroma  = sqrt (I * I + Q * Q);\n      \n      // Make the user's adjustments\n      hue += (-hueAdjust); //why negative rotation?\n      \n      // Convert back to YIQ\n      Q = chroma * sin (hue);\n      I = chroma * cos (hue);\n      \n      // Convert back to RGB\n      highp vec4    yIQ   = vec4 (YPrime, I, Q, 0.0);\n      textureColor.r = dot (yIQ, kYIQToR);\n      textureColor.g = dot (yIQ, kYIQToG);\n      textureColor.b = dot (yIQ, kYIQToB);\n      \n      // Save the result\n      gl_FragColor = textureColor;\n    }\n    "}}class h extends r.a{constructor(){super(),this.fragmentShader="\n\n    /*\n    ** Gamma correction\n    ** Details: http://blog.mouaif.org/2009/01/22/photoshop-gamma-correction-shader/\n    */\n    #define GammaCorrection(color, gamma)\t\t\t\t\t\t\t\tpow(color, 1.0 / gamma)\n    \n    /*\n    ** Levels control (input (+gamma), output)\n    ** Details: http://blog.mouaif.org/2009/01/28/levels-control-shader/\n    */    \n    #define LevelsControlInputRange(color, minInput, maxInput)\t\t\t\tmin(max(color - minInput, vec3(0.0)) / (maxInput - minInput), vec3(1.0))\n    #define LevelsControlInput(color, minInput, gamma, maxInput)\t\t\t\tGammaCorrection(LevelsControlInputRange(color, minInput, maxInput), gamma)\n    #define LevelsControlOutputRange(color, minOutput, maxOutput) \t\t\tmix(minOutput, maxOutput, color)\n    #define LevelsControl(color, minInput, gamma, maxInput, minOutput, maxOutput) \tLevelsControlOutputRange(LevelsControlInput(color, minInput, gamma, maxInput), minOutput, maxOutput)\n   \n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n\n    uniform mediump vec3 levelMinimum;\n    uniform mediump vec3 levelMiddle;\n    uniform mediump vec3 levelMaximum;\n    uniform mediump vec3 minOutput;\n    uniform mediump vec3 maxOutput;\n    \n\n    void main() {\n      lowp vec4 textureColor = texture2D(textureID, vTexCoord);\n      gl_FragColor = vec4(LevelsControl(textureColor.rgb, levelMinimum, levelMiddle, levelMaximum, minOutput, maxOutput), textureColor.a);\n    }\n\n    "}}class p extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n    uniform float threshold;\n  \n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n\n    void main() {\n      vec4 textureColor = texture2D(textureID, vTexCoord);\n\n      highp float luminance = dot(textureColor.rgb, W);\n      highp float thresholdResult = step(threshold, luminance);\n      \n      gl_FragColor = vec4(vec3(thresholdResult), textureColor.a);    \n    }\n    "}}class C extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n    uniform float intensity;\n    uniform vec3 filterColor;\n\n    const vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n\n    void main() {\n      lowp vec4 textureColor = texture2D(textureID, vTexCoord);\n      float luminance = dot(textureColor.rgb, luminanceWeighting);\n   \n      lowp vec4 desat = vec4(vec3(luminance), 1.0);\n      \n      //overlay\n      lowp vec4 outputColor = vec4(\n                                     (desat.r < 0.5 ? (2.0 * desat.r * filterColor.r) : (1.0 - 2.0 * (1.0 - desat.r) * (1.0 - filterColor.r))),\n                                     (desat.g < 0.5 ? (2.0 * desat.g * filterColor.g) : (1.0 - 2.0 * (1.0 - desat.g) * (1.0 - filterColor.g))),\n                                     (desat.b < 0.5 ? (2.0 * desat.b * filterColor.b) : (1.0 - 2.0 * (1.0 - desat.b) * (1.0 - filterColor.b))),\n                                     1.0\n                                     );\n      \n      //which is better, or are they equal?\n      gl_FragColor = vec4( mix(textureColor.rgb, outputColor.rgb, intensity), textureColor.a);     \n    \n    }\n    "}}class b extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n    uniform float opacity;\n\n    void main() {\n      lowp vec4 textureColor = texture2D(textureID, vTexCoord);\n      gl_FragColor = vec4(textureColor.rgb, textureColor.a * opacity);\n       \n    }\n    "}}class D extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n    uniform highp float redAdjustment;\n    uniform highp float greenAdjustment;\n    uniform highp float blueAdjustment;\n   \n\n    void main() {\n      vec4 textureColor = texture2D(textureID, vTexCoord);\n      gl_FragColor = vec4(textureColor.r * redAdjustment, textureColor.g * greenAdjustment, textureColor.b * blueAdjustment, textureColor.a);\n    }\n    "}}class y extends r.a{constructor(){super(),this.fragmentShader='\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n    uniform float saturation;\n\n    // Values from "Graphics Shaders: Theory and Practice" by Bailey and Cunningham\n    const mediump vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n\n    void main() {\n      vec4 textureColor = texture2D(textureID, vTexCoord);\n\n      float luminance = dot(textureColor.rgb, luminanceWeighting);\n      vec3 greyScaleColor = vec3(luminance);\n\n      gl_FragColor = vec4(mix(greyScaleColor, textureColor.rgb, saturation), textureColor.a);\n    }\n    '}}class T extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n    mat4 colorMatrix = mat4(0.393, 0.769, 0.189, 0.0,\n      0.349, 0.686, 0.168, 0.0,\n      0.272, 0.534, 0.131, 0.0,\n      0.0,   0.0,   0.0,   1.0);\n\n    void main() {\n      vec4 textureColor = texture2D(textureID, vTexCoord);\n      vec4 outputColor = textureColor * colorMatrix;        \n      gl_FragColor = outputColor;\n    }\n    "}}class I extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n    uniform lowp float temperature;\n\n    float normTemperature = (temperature < 5000.0) ? (0.0004*(temperature-5000.0)) : (0.00006*(temperature-5000.0));\n    const vec3 warmFilter = vec3(0.93, 0.54, 0.0);\n\n    void main() {\n      lowp vec4 textureColor = texture2D(textureID, vTexCoord);\n\n      lowp vec3 processed = vec3(\n        (textureColor.r < 0.5 ? (2.0 * textureColor.r * warmFilter.r) : (1.0 - 2.0 * (1.0 - textureColor.r) * (1.0 - warmFilter.r))), //adjusting temperature\n        (textureColor.g < 0.5 ? (2.0 * textureColor.g * warmFilter.g) : (1.0 - 2.0 * (1.0 - textureColor.g) * (1.0 - warmFilter.g))), \n        (textureColor.b < 0.5 ? (2.0 * textureColor.b * warmFilter.b) : (1.0 - 2.0 * (1.0 - textureColor.b) * (1.0 - warmFilter.b))));\n    \n      gl_FragColor = vec4(mix(textureColor.rgb, processed, normTemperature), textureColor.a);\n    \n    }\n    "}}class S extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n    uniform float tint;\n\n    lowp float normTint = tint/100.0;\n\n    const mat3 RGBtoYIQ = mat3(0.299, 0.587, 0.114, 0.596, -0.274, -0.322, 0.212, -0.523, 0.311);\n    const mat3 YIQtoRGB = mat3(1.0, 0.956, 0.621, 1.0, -0.272, -0.647, 1.0, -1.105, 1.702);\n\n\n    void main() {\n      vec4 textureColor = texture2D(textureID, vTexCoord);\n\n      vec3 yiq = RGBtoYIQ * textureColor.rgb; //adjusting tint\n      yiq.b = clamp(yiq.b + normTint*0.5226*0.1, -0.5226, 0.5226);\n      vec3 rgb = YIQtoRGB * yiq;\n    \n      gl_FragColor = vec4(rgb, textureColor.a);\n    \n    }\n    "}}class F extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    uniform sampler2D textureID;\n    uniform float vibrance;\n\n\n    void main() {\n      vec4 textureColor = texture2D(textureID, vTexCoord);\n\n      float average = (textureColor.r + textureColor.g + textureColor.b) / 3.0;\n      float mx = max(textureColor.r, max(textureColor.g, textureColor.b));\n      float amt = (mx - average) * (-vibrance * 3.0);\n      textureColor.rgb = mix(textureColor.rgb, vec3(mx), amt);\n      gl_FragColor = textureColor;\n    \n    }\n    "}}class _ extends r.a{constructor(){super(),this.vertexShader="\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n      \n      attribute vec3 aPosition;\n      attribute vec2 aTexCoord;\n      \n      uniform float texelWidth;\n      uniform float texelHeight; \n      uniform float flipY;\n      \n      varying vec2 vTexCoord;\n      varying vec2 leftTextureCoordinate;\n      varying vec2 rightTextureCoordinate;\n      \n      varying vec2 topTextureCoordinate;\n      varying vec2 topLeftTextureCoordinate;\n      varying vec2 topRightTextureCoordinate;\n      \n      varying vec2 bottomTextureCoordinate;\n      varying vec2 bottomLeftTextureCoordinate;\n      varying vec2 bottomRightTextureCoordinate;\n      \n      void main()\n      {\n        vec4 positionVec4 = vec4(aPosition * vec3(1.0, flipY, 1.0), 1.0);\n        positionVec4.xy = positionVec4.xy * 2.0 + vec2(-1.0, 1.0);\n        gl_Position = positionVec4;\n        \n        vec2 widthStep = vec2(texelWidth, 0.0);\n        vec2 heightStep = vec2(0.0, texelHeight);\n        vec2 widthHeightStep = vec2(texelWidth, texelHeight);\n        vec2 widthNegativeHeightStep = vec2(texelWidth, -texelHeight);\n        \n        vTexCoord = aTexCoord;\n        leftTextureCoordinate = aTexCoord - widthStep;\n        rightTextureCoordinate = aTexCoord + widthStep;\n        \n        topTextureCoordinate = aTexCoord - heightStep;\n        topLeftTextureCoordinate = aTexCoord - widthHeightStep;\n        topRightTextureCoordinate = aTexCoord + widthNegativeHeightStep;\n        \n        bottomTextureCoordinate = aTexCoord + heightStep;\n        bottomLeftTextureCoordinate = aTexCoord - widthNegativeHeightStep;\n        bottomRightTextureCoordinate = aTexCoord + widthHeightStep;\n      }\n    "}}class w extends _{constructor(){super(),this.fragmentShaderTemplate="\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      \n      varying vec2 vTexCoord;\n      varying vec2 leftTextureCoordinate;\n      varying vec2 rightTextureCoordinate;\n      \n      varying vec2 topTextureCoordinate;\n      varying vec2 topLeftTextureCoordinate;\n      varying vec2 topRightTextureCoordinate;\n      \n      varying vec2 bottomTextureCoordinate;\n      varying vec2 bottomLeftTextureCoordinate;\n      varying vec2 bottomRightTextureCoordinate;\n      \n      mat3 convolutionMatrix = <convolutionMatrixValue>;\n\n      void main()\n      {\n          mediump vec3 bottomColor = texture2D(textureID, bottomTextureCoordinate).rgb;\n          mediump vec3 bottomLeftColor = texture2D(textureID, bottomLeftTextureCoordinate).rgb;\n          mediump vec3 bottomRightColor = texture2D(textureID, bottomRightTextureCoordinate).rgb;\n          mediump vec4 centerColor = texture2D(textureID, vTexCoord);\n          mediump vec3 leftColor = texture2D(textureID, leftTextureCoordinate).rgb;\n          mediump vec3 rightColor = texture2D(textureID, rightTextureCoordinate).rgb;\n          mediump vec3 topColor = texture2D(textureID, topTextureCoordinate).rgb;\n          mediump vec3 topRightColor = texture2D(textureID, topRightTextureCoordinate).rgb;\n          mediump vec3 topLeftColor = texture2D(textureID, topLeftTextureCoordinate).rgb;\n    \n          mediump vec3 resultColor = topLeftColor * convolutionMatrix[0][0] + topColor * convolutionMatrix[0][1] + topRightColor * convolutionMatrix[0][2];\n          resultColor += leftColor * convolutionMatrix[1][0] + centerColor.rgb * convolutionMatrix[1][1] + rightColor * convolutionMatrix[1][2];\n          resultColor += bottomLeftColor * convolutionMatrix[2][0] + bottomColor * convolutionMatrix[2][1] + bottomRightColor * convolutionMatrix[2][2];\n    \n          gl_FragColor = vec4(resultColor, centerColor.a);\n      }\n    ",this.convMatrixValue="mat3(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0)",this.generateFragmentShader()}generateFragmentShader(){this.fragmentShader=this.fragmentShaderTemplate.replace("<convolutionMatrixValue>",this.convMatrixValue)}}class L extends r.a{constructor(){super(),this.vertexShader="\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      attribute vec3 aPosition;\n      attribute vec2 aTexCoord;\n      \n      uniform int radius;\n      uniform float texelWidth;\n      uniform float texelHeight; \n\n      uniform float flipY;\n      \n      varying vec2 vTexCoord;\n      varying float inputRadius;\n      varying float inputTexelWidth;\n      varying float inputTexelHeight;\n      \n      void main()\n      {\n        vec4 positionVec4 = vec4(aPosition * vec3(1.0, flipY, 1.0), 1.0);\n        positionVec4.xy = positionVec4.xy * 2.0 + vec2(-1.0, 1.0);\n        gl_Position = positionVec4;\n\n        vTexCoord = aTexCoord;\n        inputRadius = float(radius);\n        inputTexelWidth = texelWidth;\n        inputTexelHeight = texelHeight;\n      }\n    ",this.fragmentShaderTemplate="\n      #define MAX_RADIUS 10\n\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      <more uniforms>\n            \n      varying vec2 vTexCoord;\n      varying float inputRadius;\n      varying float inputTexelWidth;\n      varying float inputTexelHeight;\n\n      <weight function> \n\n      vec2 neighborCord(vec2 upleftCord, float texelWidth, float texelHeight, int row, int col) {\n        vec2 nCord = upleftCord + vec2(float(col)*texelWidth, float(row)*texelHeight);\n        return nCord;\n      }\n\n      void main()\n      {\n        vec4 textureColor = texture2D(textureID, vTexCoord);\n        vec3 resultColor = vec3(0.0, 0.0, 0.0);\n\n        float size = 2.0*inputRadius + 1.0;\n\n        for (int i=0; i<2*MAX_RADIUS+1; ++i){\n          if (size-0.1 <= float(i)) break;\n          for (int j=0; j<2*MAX_RADIUS+1; ++j){\n            if (size-0.1 <= float(j)) break;\n            vec2 upleftCord = vTexCoord - vec2(inputRadius*inputTexelWidth, inputRadius*inputTexelHeight);\n            vec2 nCord = neighborCord(upleftCord, inputTexelWidth, inputTexelHeight, i, j);\n            vec4 nColor = texture2D(textureID, nCord);\n\n            <invoke weight function>\n\n            resultColor =  resultColor + nColor.rgb * weight;\n          }        \n        }\n\n        <final adjustment>\n        \n      }\n    ",this.moreUniforms="",this.weightFunction="\n    float weight(int i, int j, float radius){\n      return 1.0 / ((2.0*radius +1.0)*(2.0*radius + 1.0));\n    }    \n    ",this.invokeWeightFunc="\n    float weight = weight(i, j, inputRadius);    \n    ",this.finalAdjustment="\n    gl_FragColor = vec4(resultColor, textureColor.a);\n    ",this.generateFragmentShader()}generateFragmentShader(){this.fragmentShader=this.fragmentShaderTemplate.replace("<more uniforms>",this.moreUniforms).replace("<weight function>",this.weightFunction).replace("<invoke weight function>",this.invokeWeightFunc).replace("<final adjustment>",this.finalAdjustment)}}class R extends L{constructor(){super(),this.finalAdjustment="\n    vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    float thresholdResult = step(dot(resultColor.rgb, W) - 0.05, dot(textureColor.rgb, W));\n    \n    gl_FragColor = vec4(vec3(thresholdResult), 1.0);\n    ",this.generateFragmentShader()}}class P extends w{constructor(){super(),this.convMatrixValue="mat3(0.0, 0.25, 0.0, 0.25, 0.0, 0.25, 0.0, 0.25, 0.0)",this.generateFragmentShader()}}class W extends w{constructor(){super(),this.convMatrixValue="mat3(-2.0, -1.0, 0.0, -1.0, 1.0, 1.0, 0.0, 1.0, 2.0)",this.generateFragmentShader()}}class E extends L{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    uniform sampler2D textureID;\n          \n    varying vec2 vTexCoord;\n    varying float inputRadius;\n    varying float inputTexelWidth;\n    varying float inputTexelHeight;\n\n    void main()\n    {\n\n      vec2 blockSize = vec2(inputRadius * inputTexelWidth, inputRadius * inputTexelHeight);\n      vec2 block = floor(vTexCoord / blockSize);\n      vec2 blockStartCoordinate = block * blockSize;\n\n      gl_FragColor = texture2D(textureID, blockStartCoordinate);\n    }\n    "}}class G extends L{constructor(){super()}}class A extends L{constructor(){super(),this.moreUniforms="\n    uniform float sigma;\n    uniform float weightSum;\n    ",this.weightFunction="\n    float weight(int i, int j, float radius, float sigma, float weightSum){\n      float size = 2.0*radius + 1.0;\n      float w = exp(-((float(i)-radius)*(float(i)-radius)+(float(j)-radius)*(float(j)-radius)) / (2.0*sigma*sigma));\n      return w/weightSum;\n    }  \n    ",this.invokeWeightFunc="\n    float weight = weight(i, j, inputRadius, sigma, weightSum); \n    ",this.generateFragmentShader(),this.apply=(e,t,n)=>{this.shader.setUniform("flipY",-1),this.shader.setUniform("texelWidth",1/n.w),this.shader.setUniform("texelHeight",1/n.h),this.shader.setUniform("textureID",e);let r=this.param.radius,o=this.param.sigma;this.shader.setUniform("weightSum",this.gaussianKernelSum(r,o));for(const[e,t]of Object.entries(this.param))this.shader.setUniform(""+e,t);t.shader(this.shader),t.rect(0,0,1,1)},this.gaussianKernelSum=(e,t)=>{let n=0;for(let r=-e;r<=e;++r)for(let o=-e;o<=e;++o){n+=Math.exp(-(r*r+o*o)/(2*t*t))}return n}}}class B extends _{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision highp float;\n    #endif\n\n    uniform sampler2D textureID;\n    \n    varying vec2 vTexCoord;\n    varying vec2 leftTextureCoordinate;\n    varying vec2 rightTextureCoordinate;\n    \n    varying vec2 topTextureCoordinate;\n    varying vec2 topLeftTextureCoordinate;\n    varying vec2 topRightTextureCoordinate;\n    \n    varying vec2 bottomTextureCoordinate;\n    varying vec2 bottomLeftTextureCoordinate;\n    varying vec2 bottomRightTextureCoordinate;\n\n    \n    \n    #define s2(a, b)\t\t\t\ttemp = a; a = min(a, b); b = max(temp, b);\n    #define mn3(a, b, c)\t\t\ts2(a, b); s2(a, c);\n    #define mx3(a, b, c)\t\t\ts2(b, c); s2(a, c);\n    \n    #define mnmx3(a, b, c)\t\t\tmx3(a, b, c); s2(a, b);                                   // 3 exchanges\n    #define mnmx4(a, b, c, d)\t\ts2(a, b); s2(c, d); s2(a, c); s2(b, d);                   // 4 exchanges\n    #define mnmx5(a, b, c, d, e)\ts2(a, b); s2(c, d); mn3(a, c, e); mx3(b, d, e);           // 6 exchanges\n    #define mnmx6(a, b, c, d, e, f) s2(a, d); s2(b, e); s2(c, f); mn3(a, b, c); mx3(d, e, f); // 7 exchanges\n  \n    void main()\n    {\n      highp vec3 v[6];\n\n      highp vec3 bottomColor = texture2D(textureID, bottomTextureCoordinate).rgb;\n      highp vec3 bottomLeftColor = texture2D(textureID, bottomLeftTextureCoordinate).rgb;\n      highp vec3 bottomRightColor = texture2D(textureID, bottomRightTextureCoordinate).rgb;\n      highp vec4 centerColor = texture2D(textureID, vTexCoord);\n      highp vec3 leftColor = texture2D(textureID, leftTextureCoordinate).rgb;\n      highp vec3 rightColor = texture2D(textureID, rightTextureCoordinate).rgb;\n      highp vec3 topColor = texture2D(textureID, topTextureCoordinate).rgb;\n      highp vec3 topRightColor = texture2D(textureID, topRightTextureCoordinate).rgb;\n      highp vec3 topLeftColor = texture2D(textureID, topLeftTextureCoordinate).rgb;\n\n      v[0] = bottomLeftColor;\n      v[1] = topRightColor;\n      v[2] = topLeftColor;\n      v[3] = bottomRightColor;\n      v[4] = leftColor;\n      v[5] = rightColor;\n\n\n      vec3 temp;\n  \n      mnmx6(v[0], v[1], v[2], v[3], v[4], v[5]);\n      \n      v[5] = bottomColor;\n                  \n      mnmx5(v[1], v[2], v[3], v[4], v[5]);\n                  \n      v[5] = topColor;\n                                \n      mnmx4(v[2], v[3], v[4], v[5]);\n                                \n      v[5] = centerColor.rgb;\n                                            \n      mnmx3(v[3], v[4], v[5]);\n    \n      gl_FragColor = vec4(v[4], centerColor.a);\n    }\n    "}}class k extends _{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    uniform sampler2D textureID;\n    \n    varying vec2 vTexCoord;\n    varying vec2 leftTextureCoordinate;\n    varying vec2 rightTextureCoordinate;\n    \n    varying vec2 topTextureCoordinate;\n    varying vec2 topLeftTextureCoordinate;\n    varying vec2 topRightTextureCoordinate;\n    \n    varying vec2 bottomTextureCoordinate;\n    varying vec2 bottomLeftTextureCoordinate;\n    varying vec2 bottomRightTextureCoordinate;\n\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n\n    void main()\n    {\n        float bottomColor = dot(texture2D(textureID, bottomTextureCoordinate).rgb, W);\n        float bottomLeftColor = dot(texture2D(textureID, bottomLeftTextureCoordinate).rgb, W);\n        float bottomRightColor = dot(texture2D(textureID, bottomRightTextureCoordinate).rgb, W);\n        float centerColor = dot(texture2D(textureID, vTexCoord).rgb, W);\n        float leftColor = dot(texture2D(textureID, leftTextureCoordinate).rgb, W);\n        float rightColor = dot(texture2D(textureID, rightTextureCoordinate).rgb, W);\n        float topColor = dot(texture2D(textureID, topTextureCoordinate).rgb, W);\n        float topRightColor = dot(texture2D(textureID, topRightTextureCoordinate).rgb, W);\n        float topLeftColor = dot(texture2D(textureID, topLeftTextureCoordinate).rgb, W);\n\n        float gx = topLeftColor + 2.0*leftColor + bottomLeftColor - topRightColor - 2.0*rightColor - bottomRightColor;\n        float gy = topLeftColor + 2.0*topColor + topRightColor - bottomLeftColor - 2.0*bottomColor - bottomRightColor;\n        float normal = sqrt(gx*gx+gy*gy)/4.0;\n    \n        gl_FragColor = vec4(vec3(normal), texture2D(textureID, vTexCoord).a);\n    }\n\n    "}}class M extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    \n    uniform sampler2D textureID;\n    uniform float texelWidth; \n    uniform float texelHeight; \n    uniform float upperThreshold; \n    uniform float lowerThreshold; \n   \n    void main()\n    {\n        vec3 currentGradientAndDirection = texture2D(textureID, vTexCoord).rgb;\n        vec2 gradientDirection = ((currentGradientAndDirection.gb * 2.0) - 1.0) * vec2(texelWidth, texelHeight);\n        \n        float firstSampledGradientMagnitude = texture2D(textureID, vTexCoord + gradientDirection).r;\n        float secondSampledGradientMagnitude = texture2D(textureID, vTexCoord - gradientDirection).r;\n        \n        float multiplier = step(firstSampledGradientMagnitude, currentGradientAndDirection.r);\n        multiplier = multiplier * step(secondSampledGradientMagnitude, currentGradientAndDirection.r);\n        \n        float thresholdCompliance = smoothstep(lowerThreshold, upperThreshold, currentGradientAndDirection.r);\n        multiplier = multiplier * thresholdCompliance;\n        \n        gl_FragColor = vec4(multiplier, multiplier, multiplier, 1.0);\n    }\n    "}}class U extends _{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision highp float;\n    #endif\n\n    uniform sampler2D textureID;\n    uniform float sumTest;\n    uniform float pixelTest;\n    \n    varying vec2 vTexCoord;\n    varying vec2 leftTextureCoordinate;\n    varying vec2 rightTextureCoordinate;\n    \n    varying vec2 topTextureCoordinate;\n    varying vec2 topLeftTextureCoordinate;\n    varying vec2 topRightTextureCoordinate;\n    \n    varying vec2 bottomTextureCoordinate;\n    varying vec2 bottomLeftTextureCoordinate;\n    varying vec2 bottomRightTextureCoordinate;\n\n    void main()\n    {\n      highp vec3 v[6];\n\n      highp vec3 bottomColor = texture2D(textureID, bottomTextureCoordinate).rgb;\n      highp vec3 bottomLeftColor = texture2D(textureID, bottomLeftTextureCoordinate).rgb;\n      highp vec3 bottomRightColor = texture2D(textureID, bottomRightTextureCoordinate).rgb;\n      highp vec4 centerColor = texture2D(textureID, vTexCoord);\n      highp vec3 leftColor = texture2D(textureID, leftTextureCoordinate).rgb;\n      highp vec3 rightColor = texture2D(textureID, rightTextureCoordinate).rgb;\n      highp vec3 topColor = texture2D(textureID, topTextureCoordinate).rgb;\n      highp vec3 topRightColor = texture2D(textureID, topRightTextureCoordinate).rgb;\n      highp vec3 topLeftColor = texture2D(textureID, topLeftTextureCoordinate).rgb;\n\n      float pixelIntensitySum = bottomLeftColor.r + topRightColor.r + topLeftColor.r + bottomRightColor.r + leftColor.r + rightColor.r + bottomColor.r + topColor.r + centerColor.r;\n      // float sumTest = step(1.5, pixelIntensitySum);\n      float sumTestColor = step(sumTest, pixelIntensitySum);\n      float pixelTestColor = step(pixelTest, centerColor.r);\n           \n      gl_FragColor = vec4(vec3(sumTestColor * pixelTestColor), 1.0);    \n    }\n    "}}class z{constructor(){this.grayscaleFilter=new x,this.gussianBlurFilter=new A,this.sobelEdgeFilter=new k,this.nonMaximumSuppressionFilter=new M,this.weakPixelInclusionFilter=new U,this.createShader=e=>{this.grayscaleFilter.shader=e.createShader(this.grayscaleFilter.vertexShader,this.grayscaleFilter.fragmentShader),this.grayscaleFilter.param={},this.gussianBlurFilter.shader=e.createShader(this.gussianBlurFilter.vertexShader,this.gussianBlurFilter.fragmentShader),this.gussianBlurFilter.param={radius:2,sigma:1},this.sobelEdgeFilter.shader=e.createShader(this.sobelEdgeFilter.vertexShader,this.sobelEdgeFilter.fragmentShader),this.sobelEdgeFilter.param={},this.nonMaximumSuppressionFilter.shader=e.createShader(this.nonMaximumSuppressionFilter.vertexShader,this.nonMaximumSuppressionFilter.fragmentShader),this.nonMaximumSuppressionFilter.param={lowerThreshold:.1,upperThreshold:.11},this.weakPixelInclusionFilter.shader=e.createShader(this.weakPixelInclusionFilter.vertexShader,this.weakPixelInclusionFilter.fragmentShader),this.weakPixelInclusionFilter.param={sumTest:.8,pixelTest:.01}},this.apply=(e,t,n)=>{this.grayscaleFilter.apply(e,t,n),this.gussianBlurFilter.apply(t.get(),t,n),this.sobelEdgeFilter.apply(t.get(),t,n),this.nonMaximumSuppressionFilter.apply(t.get(),t,n),this.weakPixelInclusionFilter.apply(t.get(),t,n)}}}class H extends r.a{constructor(){super(),this.vertexShader="\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n      \n      attribute vec3 aPosition;\n      attribute vec2 aTexCoord;\n      \n      uniform float texelWidth;\n      uniform float texelHeight; \n      uniform float flipY;\n      \n      uniform float sharpness;\n      \n      varying vec2 textureCoordinate;\n      varying vec2 leftTextureCoordinate;\n      varying vec2 rightTextureCoordinate; \n      varying vec2 topTextureCoordinate;\n      varying vec2 bottomTextureCoordinate;\n      \n      varying float centerMultiplier;\n      varying float edgeMultiplier;\n      \n      void main()\n      {\n        vec4 positionVec4 = vec4(aPosition * vec3(1.0, flipY, 1.0), 1.0);\n        positionVec4.xy = positionVec4.xy * 2.0 + vec2(-1.0, 1.0);\n        gl_Position = positionVec4;\n          \n        vec2 widthStep = vec2(texelWidth, 0.0);\n        vec2 heightStep = vec2(0.0, texelHeight);\n\n        textureCoordinate = aTexCoord.xy;\n        leftTextureCoordinate = aTexCoord.xy - widthStep;\n        rightTextureCoordinate = aTexCoord.xy + widthStep;\n        topTextureCoordinate = aTexCoord.xy + heightStep;     \n        bottomTextureCoordinate = aTexCoord.xy - heightStep;\n        \n        centerMultiplier = 1.0 + 4.0 * sharpness;\n        edgeMultiplier = sharpness;\n      }\n    ",this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying highp vec2 textureCoordinate;\n    varying highp vec2 leftTextureCoordinate;\n    varying highp vec2 rightTextureCoordinate; \n    varying highp vec2 topTextureCoordinate;\n    varying highp vec2 bottomTextureCoordinate;\n    \n    varying highp float centerMultiplier;\n    varying highp float edgeMultiplier;\n   \n    uniform sampler2D textureID;\n    \n    void main()\n    {\n        mediump vec3 textureColor = texture2D(textureID, textureCoordinate).rgb;\n        mediump vec3 leftTextureColor = texture2D(textureID, leftTextureCoordinate).rgb;\n        mediump vec3 rightTextureColor = texture2D(textureID, rightTextureCoordinate).rgb;\n        mediump vec3 topTextureColor = texture2D(textureID, topTextureCoordinate).rgb;\n        mediump vec3 bottomTextureColor = texture2D(textureID, bottomTextureCoordinate).rgb;\n   \n        gl_FragColor = vec4((textureColor * centerMultiplier - (leftTextureColor * edgeMultiplier + rightTextureColor * edgeMultiplier + topTextureColor * edgeMultiplier + bottomTextureColor * edgeMultiplier)), texture2D(textureID, bottomTextureCoordinate).w);\n    }\n    "}}class O extends r.a{constructor(){super(),this.apply=(e,t,n)=>{this.param.width=this.param.x+this.param.width>e.width?e.width-this.param.x:this.param.width,this.param.height=this.param.y+this.param.height>e.height?e.height-this.param.y:this.param.height,t.resizeCanvas(this.param.width,this.param.height);let r=t.createImage(this.param.width,this.param.height);r.copy(e,this.param.x,this.param.y,this.param.width,this.param.height,0,0,this.param.width,this.param.height),this.shader.setUniform("flipY",-1),this.shader.setUniform("textureID",r);for(const[e,t]of Object.entries(this.param))this.shader.setUniform(""+e,t);t.shader(this.shader),t.rect(0,0,1,1)}}}class j extends r.a{constructor(){super(),this.vertexShader="\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n      \n      attribute vec3 aPosition;\n      attribute vec2 aTexCoord;\n      \n      uniform float texelWidth;\n      uniform float texelHeight; \n      uniform float flipY;\n      \n      varying vec2 centerTextureCoordinate;\n      varying vec2 oneStepLeftTextureCoordinate;\n      varying vec2 twoStepsLeftTextureCoordinate;\n      varying vec2 threeStepsLeftTextureCoordinate;\n      varying vec2 fourStepsLeftTextureCoordinate;\n      varying vec2 oneStepRightTextureCoordinate;\n      varying vec2 twoStepsRightTextureCoordinate;\n      varying vec2 threeStepsRightTextureCoordinate;\n      varying vec2 fourStepsRightTextureCoordinate;\n     \n      void main()\n      {\n        vec4 positionVec4 = vec4(aPosition * vec3(1.0, flipY, 1.0), 1.0);\n        positionVec4.xy = positionVec4.xy * 2.0 + vec2(-1.0, 1.0);\n        gl_Position = positionVec4;\n          \n        vec2 firstOffset = vec2(texelWidth, texelHeight);\n        vec2 secondOffset = vec2(2.0 * texelWidth, 2.0 * texelHeight);\n        vec2 thirdOffset = vec2(3.0 * texelWidth, 3.0 * texelHeight);\n        vec2 fourthOffset = vec2(4.0 * texelWidth, 4.0 * texelHeight);\n        \n        centerTextureCoordinate = aTexCoord;\n        oneStepLeftTextureCoordinate = aTexCoord - firstOffset;\n        twoStepsLeftTextureCoordinate = aTexCoord - secondOffset;\n        threeStepsLeftTextureCoordinate = aTexCoord - thirdOffset;\n        fourStepsLeftTextureCoordinate = aTexCoord - fourthOffset;\n        oneStepRightTextureCoordinate = aTexCoord + firstOffset;\n        twoStepsRightTextureCoordinate = aTexCoord + secondOffset;\n        threeStepsRightTextureCoordinate = aTexCoord + thirdOffset;\n        fourStepsRightTextureCoordinate = aTexCoord + fourthOffset;\n      }\n    ",this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    uniform sampler2D textureID;\n \n    varying vec2 centerTextureCoordinate;\n    varying vec2 oneStepLeftTextureCoordinate;\n    varying vec2 twoStepsLeftTextureCoordinate;\n    varying vec2 threeStepsLeftTextureCoordinate;\n    varying vec2 fourStepsLeftTextureCoordinate;\n    varying vec2 oneStepRightTextureCoordinate;\n    varying vec2 twoStepsRightTextureCoordinate;\n    varying vec2 threeStepsRightTextureCoordinate;\n    varying vec2 fourStepsRightTextureCoordinate;\n       \n    void main()\n    {\n      lowp vec4 fragmentColor = texture2D(textureID, centerTextureCoordinate) * 0.38026;\n      \n      fragmentColor += texture2D(textureID, oneStepLeftTextureCoordinate) * 0.27667;\n      fragmentColor += texture2D(textureID, oneStepRightTextureCoordinate) * 0.27667;\n      \n      fragmentColor += texture2D(textureID, twoStepsLeftTextureCoordinate) * 0.08074;\n      fragmentColor += texture2D(textureID, twoStepsRightTextureCoordinate) * 0.08074;\n  \n      fragmentColor += texture2D(textureID, threeStepsLeftTextureCoordinate) * -0.02612;\n      fragmentColor += texture2D(textureID, threeStepsRightTextureCoordinate) * -0.02612;\n  \n      fragmentColor += texture2D(textureID, fourStepsLeftTextureCoordinate) * -0.02143;\n      fragmentColor += texture2D(textureID, fourStepsRightTextureCoordinate) * -0.02143;\n  \n      gl_FragColor = fragmentColor;\n    }    \n    "}}class V extends r.a{constructor(){super(),this.vertexShader="\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n      \n      attribute vec3 aPosition;\n      attribute vec2 aTexCoord;\n\n      const int GAUSSIAN_SAMPLES = 9;\n\n      uniform float texelWidth;\n      uniform float texelHeight; \n      uniform float flipY;\n      \n      varying vec2 textureCoordinate;\n      varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n      \n      void main()\n      {\n        vec4 positionVec4 = vec4(aPosition * vec3(1.0, flipY, 1.0), 1.0);\n        positionVec4.xy = positionVec4.xy * 2.0 + vec2(-1.0, 1.0);\n        gl_Position = positionVec4;\n\n        textureCoordinate = aTexCoord.xy;\n        \n        // Calculate the positions for the blur\n        int multiplier = 0;\n        vec2 blurStep;\n        vec2 singleStepOffset = vec2(texelWidth, texelHeight);\n        \n        for (int i = 0; i < GAUSSIAN_SAMPLES; i++)\n        {\n            multiplier = (i - ((GAUSSIAN_SAMPLES - 1) / 2));\n            // Blur in x (horizontal)\n            blurStep = float(multiplier) * singleStepOffset;\n            blurCoordinates[i] = aTexCoord.xy + blurStep;\n        }\n    }\n\n    ",this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    uniform sampler2D textureID;\n \n    const lowp int GAUSSIAN_SAMPLES = 9;\n    \n    varying highp vec2 textureCoordinate;\n    varying highp vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n    \n    uniform float distanceNormalizationFactor;\n    \n    void main()\n    {\n        vec4 centralColor;\n        float gaussianWeightTotal;\n        vec4 sum;\n        vec4 sampleColor;\n        float distanceFromCentralColor;\n        float gaussianWeight;\n        \n        centralColor = texture2D(textureID, blurCoordinates[4]);\n        gaussianWeightTotal = 0.18;\n        sum = centralColor * 0.18;\n        \n        sampleColor = texture2D(textureID, blurCoordinates[0]);\n        distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n        gaussianWeight = 0.05 * (1.0 - distanceFromCentralColor);\n        gaussianWeightTotal += gaussianWeight;\n        sum += sampleColor * gaussianWeight;\n   \n        sampleColor = texture2D(textureID, blurCoordinates[1]);\n        distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n        gaussianWeight = 0.09 * (1.0 - distanceFromCentralColor);\n        gaussianWeightTotal += gaussianWeight;\n        sum += sampleColor * gaussianWeight;\n   \n        sampleColor = texture2D(textureID, blurCoordinates[2]);\n        distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n        gaussianWeight = 0.12 * (1.0 - distanceFromCentralColor);\n        gaussianWeightTotal += gaussianWeight;\n        sum += sampleColor * gaussianWeight;\n   \n        sampleColor = texture2D(textureID, blurCoordinates[3]);\n        distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n        gaussianWeight = 0.15 * (1.0 - distanceFromCentralColor);\n        gaussianWeightTotal += gaussianWeight;\n        sum += sampleColor * gaussianWeight;\n   \n        sampleColor = texture2D(textureID, blurCoordinates[5]);\n        distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n        gaussianWeight = 0.15 * (1.0 - distanceFromCentralColor);\n        gaussianWeightTotal += gaussianWeight;\n        sum += sampleColor * gaussianWeight;\n   \n        sampleColor = texture2D(textureID, blurCoordinates[6]);\n        distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n        gaussianWeight = 0.12 * (1.0 - distanceFromCentralColor);\n        gaussianWeightTotal += gaussianWeight;\n        sum += sampleColor * gaussianWeight;\n   \n        sampleColor = texture2D(textureID, blurCoordinates[7]);\n        distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n        gaussianWeight = 0.09 * (1.0 - distanceFromCentralColor);\n        gaussianWeightTotal += gaussianWeight;\n        sum += sampleColor * gaussianWeight;\n   \n        sampleColor = texture2D(textureID, blurCoordinates[8]);\n        distanceFromCentralColor = min(distance(centralColor, sampleColor) * distanceNormalizationFactor, 1.0);\n        gaussianWeight = 0.05 * (1.0 - distanceFromCentralColor);\n        gaussianWeightTotal += gaussianWeight;\n        sum += sampleColor * gaussianWeight;\n        \n        gl_FragColor = sum / gaussianWeightTotal;\n    }\n\n    "}}class Y extends r.a{constructor(){super(),this.vertexShader="\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n      \n      attribute vec3 aPosition;\n      attribute vec2 aTexCoord;\n      \n      uniform float texelWidth;\n      uniform float texelHeight; \n      uniform float flipY;\n      uniform vec2 directionalTexelStep;\n \n      varying vec2 textureCoordinate;\n      varying vec2 oneStepBackTextureCoordinate;\n      varying vec2 twoStepsBackTextureCoordinate;\n      varying vec2 threeStepsBackTextureCoordinate;\n      varying vec2 fourStepsBackTextureCoordinate;\n      varying vec2 oneStepForwardTextureCoordinate;\n      varying vec2 twoStepsForwardTextureCoordinate;\n      varying vec2 threeStepsForwardTextureCoordinate;\n      varying vec2 fourStepsForwardTextureCoordinate;\n      \n      void main()\n      {\n        vec4 positionVec4 = vec4(aPosition * vec3(1.0, flipY, 1.0), 1.0);\n        positionVec4.xy = positionVec4.xy * 2.0 + vec2(-1.0, 1.0);\n        gl_Position = positionVec4;\n          \n        textureCoordinate = aTexCoord.xy;\n        oneStepBackTextureCoordinate = aTexCoord.xy - directionalTexelStep;\n        twoStepsBackTextureCoordinate = aTexCoord.xy - 2.0 * directionalTexelStep;\n        threeStepsBackTextureCoordinate = aTexCoord.xy - 3.0 * directionalTexelStep;\n        fourStepsBackTextureCoordinate = aTexCoord.xy - 4.0 * directionalTexelStep;\n        oneStepForwardTextureCoordinate = aTexCoord.xy + directionalTexelStep;\n        twoStepsForwardTextureCoordinate = aTexCoord.xy + 2.0 * directionalTexelStep;\n        threeStepsForwardTextureCoordinate = aTexCoord.xy + 3.0 * directionalTexelStep;\n        fourStepsForwardTextureCoordinate = aTexCoord.xy + 4.0 * directionalTexelStep;\n      }\n    ",this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    uniform sampler2D textureID;\n \n    varying vec2 textureCoordinate;\n    varying vec2 oneStepBackTextureCoordinate;\n    varying vec2 twoStepsBackTextureCoordinate;\n    varying vec2 threeStepsBackTextureCoordinate;\n    varying vec2 fourStepsBackTextureCoordinate;\n    varying vec2 oneStepForwardTextureCoordinate;\n    varying vec2 twoStepsForwardTextureCoordinate;\n    varying vec2 threeStepsForwardTextureCoordinate;\n    varying vec2 fourStepsForwardTextureCoordinate;\n    \n    void main()\n    {\n        vec4 fragmentColor = texture2D(textureID, textureCoordinate) * 0.18;\n        fragmentColor += texture2D(textureID, oneStepBackTextureCoordinate) * 0.15;\n        fragmentColor += texture2D(textureID, twoStepsBackTextureCoordinate) *  0.12;\n        fragmentColor += texture2D(textureID, threeStepsBackTextureCoordinate) * 0.09;\n        fragmentColor += texture2D(textureID, fourStepsBackTextureCoordinate) * 0.05;\n        fragmentColor += texture2D(textureID, oneStepForwardTextureCoordinate) * 0.15;\n        fragmentColor += texture2D(textureID, twoStepsForwardTextureCoordinate) *  0.12;\n        fragmentColor += texture2D(textureID, threeStepsForwardTextureCoordinate) * 0.09;\n        fragmentColor += texture2D(textureID, fourStepsForwardTextureCoordinate) * 0.05;\n   \n        gl_FragColor = fragmentColor;\n    }\n    "}}class N extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n    \n    uniform sampler2D textureID;\n    varying vec2 vTexCoord;\n    \n    uniform highp vec2 blurCenter;\n    uniform highp float blurSize;\n    \n    void main()\n    {\n        // TODO: Do a more intelligent scaling based on resolution here\n        highp vec2 samplingOffset = 1.0/100.0 * (blurCenter - vTexCoord) * blurSize;\n        \n        lowp vec4 fragmentColor = texture2D(textureID, vTexCoord) * 0.18;\n        fragmentColor += texture2D(textureID, vTexCoord + samplingOffset) * 0.15;\n        fragmentColor += texture2D(textureID, vTexCoord + (2.0 * samplingOffset)) *  0.12;\n        fragmentColor += texture2D(textureID, vTexCoord + (3.0 * samplingOffset)) * 0.09;\n        fragmentColor += texture2D(textureID, vTexCoord + (4.0 * samplingOffset)) * 0.05;\n        fragmentColor += texture2D(textureID, vTexCoord - samplingOffset) * 0.15;\n        fragmentColor += texture2D(textureID, vTexCoord - (2.0 * samplingOffset)) *  0.12;\n        fragmentColor += texture2D(textureID, vTexCoord - (3.0 * samplingOffset)) * 0.09;\n        fragmentColor += texture2D(textureID, vTexCoord - (4.0 * samplingOffset)) * 0.05;\n        \n        gl_FragColor = fragmentColor;\n    }\n    "}}class X extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;\n    \n    uniform sampler2D inputImageTexture;\n    uniform sampler2D inputImageTexture2; \n    \n    uniform float topFocusLevel;\n    uniform float bottomFocusLevel;\n    uniform float focusFallOffRate;\n    \n    void main()\n    {\n        lowp vec4 sharpImageColor = texture2D(inputImageTexture, vTexCoord);\n        lowp vec4 blurredImageColor = texture2D(inputImageTexture2, vTexCoord);\n        \n        float blurIntensity = 1.0 - smoothstep(topFocusLevel - focusFallOffRate, topFocusLevel, vTexCoord.y);\n        blurIntensity = blurIntensity * smoothstep(bottomFocusLevel, bottomFocusLevel + focusFallOffRate, vTexCoord.y);\n        \n        gl_FragColor = mix(sharpImageColor, blurredImageColor, blurIntensity);\n    }\n    ",this.gussianBlurFilter=new A,this.createShader=e=>{this.gussianBlurFilter.shader=e.createShader(this.gussianBlurFilter.vertexShader,this.gussianBlurFilter.fragmentShader),this.gussianBlurFilter.param={radius:this.param.blurRadius,sigma:this.param.blurSigma},this.shader=e.createShader(this.vertexShader,this.fragmentShader)},this.apply=(e,t,n)=>{this.gussianBlurFilter.apply(e,t,n),this.shader.setUniform("flipY",-1),this.shader.setUniform("texelWidth",1/n.w),this.shader.setUniform("texelHeight",1/n.h),this.shader.setUniform("inputImageTexture",e),this.shader.setUniform("inputImageTexture2",t.get());for(const[e,t]of Object.entries(this.param))this.shader.setUniform(""+e,t);t.shader(this.shader),t.rect(0,0,1,1)}}}class Q extends L{constructor(){super(),this.fragmentShader="\n    \n    #define MAX_RADIUS 10\n\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    uniform sampler2D textureID;\n          \n    varying vec2 vTexCoord;\n    varying float inputRadius;\n    varying float inputTexelWidth;\n    varying float inputTexelHeight;\n\n    vec2 neighborCord(float texelWidth, float texelHeight, int step) {\n      vec2 nCord = vTexCoord + vec2(float(step)*texelWidth, float(step)*texelHeight);\n      return nCord;\n    }\n\n    void main()\n    {\n      vec4 textureColor = texture2D(textureID, vTexCoord);\n      vec3 resultColor = vec3(0.0, 0.0, 0.0);\n\n      vec4 maxColor = vec4(0.0, 0.0, 0.0, 0.0);\n      for (int i=1; i<2*MAX_RADIUS+1; ++i){\n        if (inputRadius+0.1 <= float(i)) break;\n        vec2 leftCord = neighborCord(inputTexelWidth, inputTexelHeight, -i);\n        vec2 rightCord = neighborCord(inputTexelWidth, inputTexelHeight, i);\n        vec4 leftColor = texture2D(textureID, leftCord);\n        vec4 rightColor = texture2D(textureID, rightCord);\n\n        maxColor = max(maxColor, leftColor);\n        maxColor = max(maxColor, rightColor);\n      }\n\n      maxColor = max(maxColor, textureColor);\n\n      gl_FragColor = maxColor;\n    }\n  "}}class q extends L{constructor(){super(),this.fragmentShader="\n    \n    #define max_RADIUS 10\n\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    uniform sampler2D textureID;\n          \n    varying vec2 vTexCoord;\n    varying float inputRadius;\n    varying float inputTexelWidth;\n    varying float inputTexelHeight;\n\n    vec2 neighborCord(float texelWidth, float texelHeight, int step) {\n      vec2 nCord = vTexCoord + vec2(float(step)*texelWidth, float(step)*texelHeight);\n      return nCord;\n    }\n\n    void main()\n    {\n      vec4 textureColor = texture2D(textureID, vTexCoord);\n      vec3 resultColor = vec3(0.0, 0.0, 0.0);\n\n      vec4 minColor = vec4(1.0, 1.0, 1.0, 1.0);\n      for (int i=1; i<2*max_RADIUS+1; ++i){\n        if (inputRadius+0.1 <= float(i)) break;\n        vec2 leftCord = neighborCord(inputTexelWidth, inputTexelHeight, -i);\n        vec2 rightCord = neighborCord(inputTexelWidth, inputTexelHeight, i);\n        vec4 leftColor = texture2D(textureID, leftCord);\n        vec4 rightColor = texture2D(textureID, rightCord);\n\n        minColor = min(minColor, leftColor);\n        minColor = min(minColor, rightColor);\n      }\n\n      minColor = min(minColor, textureColor);\n\n      gl_FragColor = minColor;\n    }\n  "}}class ${constructor(){this.dilationFilter=new Q,this.erosionFilter=new q,this.createShader=e=>{this.dilationFilter.shader=e.createShader(this.dilationFilter.vertexShader,this.dilationFilter.fragmentShader),this.dilationFilter.param={radius:this.param.radius},this.erosionFilter.shader=e.createShader(this.erosionFilter.vertexShader,this.erosionFilter.fragmentShader),this.erosionFilter.param={radius:this.param.radius}},this.apply=(e,t,n)=>{this.erosionFilter.apply(e,t,n),this.dilationFilter.apply(t.get(),t,n)}}}class K{constructor(){this.dilationFilter=new Q,this.erosionFilter=new q,this.createShader=e=>{this.dilationFilter.shader=e.createShader(this.dilationFilter.vertexShader,this.dilationFilter.fragmentShader),this.dilationFilter.param={radius:this.param.radius},this.erosionFilter.shader=e.createShader(this.erosionFilter.vertexShader,this.erosionFilter.fragmentShader),this.erosionFilter.param={radius:this.param.radius}},this.apply=(e,t,n)=>{this.dilationFilter.apply(t.get(),t,n),this.erosionFilter.apply(e,t,n)}}}class J extends _{constructor(){super(),this.fragmentShader="\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      \n      varying vec2 vTexCoord;\n      varying vec2 leftTextureCoordinate;\n      varying vec2 rightTextureCoordinate;\n      \n      varying vec2 topTextureCoordinate;\n      varying vec2 topLeftTextureCoordinate;\n      varying vec2 topRightTextureCoordinate;\n      \n      varying vec2 bottomTextureCoordinate;\n      varying vec2 bottomLeftTextureCoordinate;\n      varying vec2 bottomRightTextureCoordinate;\n\n      void main()\n      {\n          float bottomIntensity = texture2D(textureID, bottomTextureCoordinate).r;\n          float bottomLeftIntensity = texture2D(textureID, bottomLeftTextureCoordinate).r;\n          float bottomRightIntensity = texture2D(textureID, bottomRightTextureCoordinate).r;\n          float centerIntensity = texture2D(textureID, vTexCoord).r;\n          float leftIntensity = texture2D(textureID, leftTextureCoordinate).r;\n          float rightIntensity = texture2D(textureID, rightTextureCoordinate).r;\n          float topIntensity = texture2D(textureID, topTextureCoordinate).r;\n          float topRightIntensity = texture2D(textureID, topRightTextureCoordinate).r;\n          float topLeftIntensity = texture2D(textureID, topLeftTextureCoordinate).r;\n    \n\n          float byteTally = 1.0 / 255.0 * step(centerIntensity, topRightIntensity);\n          byteTally += 2.0 / 255.0 * step(centerIntensity, topIntensity);\n          byteTally += 4.0 / 255.0 * step(centerIntensity, topLeftIntensity);\n          byteTally += 8.0 / 255.0 * step(centerIntensity, leftIntensity);\n          byteTally += 16.0 / 255.0 * step(centerIntensity, bottomLeftIntensity);\n          byteTally += 32.0 / 255.0 * step(centerIntensity, bottomIntensity);\n          byteTally += 64.0 / 255.0 * step(centerIntensity, bottomRightIntensity);\n          byteTally += 128.0 / 255.0 * step(centerIntensity, rightIntensity);\n               \n          gl_FragColor = vec4(byteTally, byteTally, byteTally, 1.0);\n      }\n    "}}class Z extends _{constructor(){super(),this.fragmentShader="\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      \n      varying vec2 vTexCoord;\n      varying vec2 leftTextureCoordinate;\n      varying vec2 rightTextureCoordinate;\n      \n      varying vec2 topTextureCoordinate;\n      varying vec2 topLeftTextureCoordinate;\n      varying vec2 topRightTextureCoordinate;\n      \n      varying vec2 bottomTextureCoordinate;\n      varying vec2 bottomLeftTextureCoordinate;\n      varying vec2 bottomRightTextureCoordinate;\n\n      void main()\n      {\n          vec3 bottomColor = texture2D(textureID, bottomTextureCoordinate).rgb;\n          vec3 bottomLeftColor = texture2D(textureID, bottomLeftTextureCoordinate).rgb;\n          vec3 bottomRightColor = texture2D(textureID, bottomRightTextureCoordinate).rgb;\n          vec4 centerColor = texture2D(textureID, vTexCoord);\n          vec3 leftColor = texture2D(textureID, leftTextureCoordinate).rgb;\n          vec3 rightColor = texture2D(textureID, rightTextureCoordinate).rgb;\n          vec3 topColor = texture2D(textureID, topTextureCoordinate).rgb;\n          vec3 topRightColor = texture2D(textureID, topRightTextureCoordinate).rgb;\n          vec3 topLeftColor = texture2D(textureID, topLeftTextureCoordinate).rgb;\n    \n\n          vec3 byteTally;\n          for (int i=0; i<3; i++){\n            byteTally[i] = 1.0 / 255.0 * step(centerColor[i], topRightColor)[i];\n            byteTally[i] += 2.0 / 255.0 * step(centerColor[i], topColor[i]);\n            byteTally[i] += 4.0 / 255.0 * step(centerColor[i], topLeftColor[i]);\n            byteTally[i] += 8.0 / 255.0 * step(centerColor[i], leftColor[i]);\n            byteTally[i] += 16.0 / 255.0 * step(centerColor[i], bottomLeftColor[i]);\n            byteTally[i] += 32.0 / 255.0 * step(centerColor[i], bottomColor[i]);\n            byteTally[i] += 64.0 / 255.0 * step(centerColor[i], bottomRightColor[i]);\n            byteTally[i] += 128.0 / 255.0 * step(centerColor[i], rightColor[i]);  \n          }          \n          gl_FragColor = vec4(byteTally, 1.0);\n      }\n    "}}class ee extends r.a{constructor(){super(),this.vertexShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    attribute vec3 aPosition;\n    attribute vec2 aTexCoord;\n    \n    uniform float texelWidth;\n    uniform float texelHeight; \n    uniform float flipY;\n    \n    uniform sampler2D textureID;\n    \n    varying vec2 textureCoordinate;\n    varying vec2 pointATextureCoordinate;\n    varying vec2 pointBTextureCoordinate;\n    varying vec2 pointCTextureCoordinate;\n    varying vec2 pointDTextureCoordinate;\n    varying vec2 pointETextureCoordinate;\n    varying vec2 pointFTextureCoordinate;\n    varying vec2 pointGTextureCoordinate;\n    varying vec2 pointHTextureCoordinate;\n   \n    void main()\n    {\n        vec4 positionVec4 = vec4(aPosition * vec3(1.0, flipY, 1.0), 1.0);\n        positionVec4.xy = positionVec4.xy * 2.0 + vec2(-1.0, 1.0);\n        gl_Position = positionVec4;\n        \n        float tripleTexelWidth = 3.0 * texelWidth;\n        float tripleTexelHeight = 3.0 * texelHeight;\n        \n        textureCoordinate = aTexCoord.xy;\n        \n        pointATextureCoordinate = vec2(textureCoordinate.x + tripleTexelWidth, textureCoordinate.y + texelHeight);\n        pointBTextureCoordinate = vec2(textureCoordinate.x + texelWidth, textureCoordinate.y + tripleTexelHeight);\n        pointCTextureCoordinate = vec2(textureCoordinate.x - texelWidth, textureCoordinate.y + tripleTexelHeight);\n        pointDTextureCoordinate = vec2(textureCoordinate.x - tripleTexelWidth, textureCoordinate.y + texelHeight);\n        pointETextureCoordinate = vec2(textureCoordinate.x - tripleTexelWidth, textureCoordinate.y - texelHeight);\n        pointFTextureCoordinate = vec2(textureCoordinate.x - texelWidth, textureCoordinate.y - tripleTexelHeight);\n        pointGTextureCoordinate = vec2(textureCoordinate.x + texelWidth, textureCoordinate.y - tripleTexelHeight);\n        pointHTextureCoordinate = vec2(textureCoordinate.x + tripleTexelWidth, textureCoordinate.y - texelHeight);\n    }\n    \n    ",this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n    \n    uniform sampler2D textureID;\n\n    varying vec2 textureCoordinate;\n    varying vec2 pointATextureCoordinate;\n    varying vec2 pointBTextureCoordinate;\n    varying vec2 pointCTextureCoordinate;\n    varying vec2 pointDTextureCoordinate;\n    varying vec2 pointETextureCoordinate;\n    varying vec2 pointFTextureCoordinate;\n    varying vec2 pointGTextureCoordinate;\n    varying vec2 pointHTextureCoordinate;  \n\n    const float PITwo = 6.2832;\n    const float PI = 3.1416;\n    void main()\n    {\n        vec3 centerColor = texture2D(textureID, textureCoordinate).rgb;\n        \n        vec3 pointAColor = texture2D(textureID, pointATextureCoordinate).rgb;\n        vec3 pointBColor = texture2D(textureID, pointBTextureCoordinate).rgb;\n        vec3 pointCColor = texture2D(textureID, pointCTextureCoordinate).rgb;\n        vec3 pointDColor = texture2D(textureID, pointDTextureCoordinate).rgb;\n        vec3 pointEColor = texture2D(textureID, pointETextureCoordinate).rgb;\n        vec3 pointFColor = texture2D(textureID, pointFTextureCoordinate).rgb;\n        vec3 pointGColor = texture2D(textureID, pointGTextureCoordinate).rgb;\n        vec3 pointHColor = texture2D(textureID, pointHTextureCoordinate).rgb;\n        \n        vec3 colorComparison = ((pointAColor + pointBColor + pointCColor + pointDColor + pointEColor + pointFColor + pointGColor + pointHColor) * 0.125) - centerColor;\n        \n        // Direction calculation drawn from Appendix B of Seth Hall's Ph.D. thesis\n        \n        vec3 dirX = (pointAColor*0.94868) + (pointBColor*0.316227) - (pointCColor*0.316227) - (pointDColor*0.94868) - (pointEColor*0.94868) - (pointFColor*0.316227) + (pointGColor*0.316227) + (pointHColor*0.94868);\n        vec3 dirY = (pointAColor*0.316227) + (pointBColor*0.94868) + (pointCColor*0.94868) + (pointDColor*0.316227) - (pointEColor*0.316227) - (pointFColor*0.94868) - (pointGColor*0.94868) - (pointHColor*0.316227);\n        vec3 absoluteDifference = abs(colorComparison);\n        float componentLength = length(colorComparison);\n        float avgX = dot(absoluteDifference, dirX) / componentLength;\n        float avgY = dot(absoluteDifference, dirY) / componentLength;\n        float angle = atan(avgY, avgX);\n        \n        vec3 normalizedColorComparison = (colorComparison + 1.0) * 0.5;\n        \n        gl_FragColor = vec4(normalizedColorComparison, (angle+PI)/PITwo);\n    }\n    "}}class te{constructor(){this.boxBlurFilter=new G,this.colourFASTSamplingFilter=new ee,this.createShader=e=>{this.boxBlurFilter.shader=e.createShader(this.boxBlurFilter.vertexShader,this.boxBlurFilter.fragmentShader),this.boxBlurFilter.param={radius:this.param.radius},this.colourFASTSamplingFilter.shader=e.createShader(this.colourFASTSamplingFilter.vertexShader,this.colourFASTSamplingFilter.fragmentShader),this.colourFASTSamplingFilter.param={}},this.apply=(e,t,n)=>{this.boxBlurFilter.apply(t.get(),t,n),this.colourFASTSamplingFilter.apply(e,t,n)}}}class ne extends _{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    uniform sampler2D textureID;\n    uniform float edgeStrength;\n    \n    varying vec2 vTexCoord;\n    varying vec2 leftTextureCoordinate;\n    varying vec2 rightTextureCoordinate;\n    \n    varying vec2 topTextureCoordinate;\n    varying vec2 topLeftTextureCoordinate;\n    varying vec2 topRightTextureCoordinate;\n    \n    varying vec2 bottomTextureCoordinate;\n    varying vec2 bottomLeftTextureCoordinate;\n    varying vec2 bottomRightTextureCoordinate;\n\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n\n    void main()\n    {\n        float bottomIntensity = dot(texture2D(textureID, bottomTextureCoordinate).rgb, W);\n        float bottomLeftIntensity = dot(texture2D(textureID, bottomLeftTextureCoordinate).rgb, W);\n        float bottomRightIntensity = dot(texture2D(textureID, bottomRightTextureCoordinate).rgb, W);\n        float centerIntensity = dot(texture2D(textureID, vTexCoord).rgb, W);\n        float leftIntensity = dot(texture2D(textureID, leftTextureCoordinate).rgb, W);\n        float rightIntensity = dot(texture2D(textureID, rightTextureCoordinate).rgb, W);\n        float topIntensity = dot(texture2D(textureID, topTextureCoordinate).rgb, W);\n        float topRightIntensity = dot(texture2D(textureID, topRightTextureCoordinate).rgb, W);\n        float topLeftIntensity = dot(texture2D(textureID, topLeftTextureCoordinate).rgb, W);\n\n        float h = -topLeftIntensity - topIntensity - topRightIntensity + bottomLeftIntensity + bottomIntensity + bottomRightIntensity;\n        float v = -bottomLeftIntensity - leftIntensity - topLeftIntensity + bottomRightIntensity + rightIntensity + topRightIntensity;\n        \n        float mag = length(vec2(h, v)) * edgeStrength;\n        \n        gl_FragColor = vec4(vec3(mag), 1.0);\n    }\n    "}}class re extends _{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    uniform sampler2D textureID;\n    uniform float edgeStrength;\n    \n    varying vec2 vTexCoord;\n    varying vec2 leftTextureCoordinate;\n    varying vec2 rightTextureCoordinate;\n    \n    varying vec2 topTextureCoordinate;\n    varying vec2 topLeftTextureCoordinate;\n    varying vec2 topRightTextureCoordinate;\n    \n    varying vec2 bottomTextureCoordinate;\n    varying vec2 bottomLeftTextureCoordinate;\n    varying vec2 bottomRightTextureCoordinate;\n\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n\n    void main()\n    {\n        float bottomIntensity = dot(texture2D(textureID, bottomTextureCoordinate).rgb, W);\n        float bottomLeftIntensity = dot(texture2D(textureID, bottomLeftTextureCoordinate).rgb, W);\n        float bottomRightIntensity = dot(texture2D(textureID, bottomRightTextureCoordinate).rgb, W);\n        float centerIntensity = dot(texture2D(textureID, vTexCoord).rgb, W);\n        float leftIntensity = dot(texture2D(textureID, leftTextureCoordinate).rgb, W);\n        float rightIntensity = dot(texture2D(textureID, rightTextureCoordinate).rgb, W);\n        float topIntensity = dot(texture2D(textureID, topTextureCoordinate).rgb, W);\n        float topRightIntensity = dot(texture2D(textureID, topRightTextureCoordinate).rgb, W);\n        float topLeftIntensity = dot(texture2D(textureID, topLeftTextureCoordinate).rgb, W);\n\n        float verticalDerivative = -topLeftIntensity - topIntensity - topRightIntensity + bottomLeftIntensity + bottomIntensity + bottomRightIntensity;\n        float horizontalDerivative = -bottomLeftIntensity - leftIntensity - topLeftIntensity + bottomRightIntensity + rightIntensity + topRightIntensity;\n        verticalDerivative = verticalDerivative * edgeStrength;\n        horizontalDerivative = horizontalDerivative * edgeStrength;\n        \n        // Scaling the X * Y operation so that negative numbers are not clipped in the 0..1 range. This will be expanded in the corner detection filter\n        gl_FragColor = vec4(horizontalDerivative * horizontalDerivative, verticalDerivative * verticalDerivative, ((verticalDerivative * horizontalDerivative) + 1.0) / 2.0, 1.0);\n    }\n    "}}class oe extends r.a{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;   \n    uniform sampler2D inputImageTexture;\n\n    uniform float sensitivity;\n \n    const float harrisConstant = 0.04;\n    \n    void main()\n    {\n      vec3 derivativeElements = texture2D(inputImageTexture, vTexCoord).rgb;\n      \n      float derivativeSum = derivativeElements.x + derivativeElements.y;\n      \n      float zElement = (derivativeElements.z * 2.0) - 1.0;\n  \n      // R = Ix^2 * Iy^2 - Ixy * Ixy - k * (Ix^2 + Iy^2)^2\n      float cornerness = derivativeElements.x * derivativeElements.y - (zElement * zElement) - harrisConstant * derivativeSum * derivativeSum;\n      \n      gl_FragColor = vec4(vec3(cornerness * sensitivity), 1.0);\n    }    \n    ",this.xyDerivativeFilter=new re,this.gussianBlurFilter=new A,this.nonMaximumSuppressionFilter=new M,this.createShader=e=>{this.xyDerivativeFilter.shader=e.createShader(this.xyDerivativeFilter.vertexShader,this.xyDerivativeFilter.fragmentShader),this.xyDerivativeFilter.param={edgeStrength:2},this.gussianBlurFilter.shader=e.createShader(this.gussianBlurFilter.vertexShader,this.gussianBlurFilter.fragmentShader),this.gussianBlurFilter.param={radius:this.param.blurRadius,sigma:this.param.blurSigma},this.nonMaximumSuppressionFilter.shader=e.createShader(this.nonMaximumSuppressionFilter.vertexShader,this.nonMaximumSuppressionFilter.fragmentShader),this.nonMaximumSuppressionFilter.param={},this.shader=e.createShader(this.vertexShader,this.fragmentShader)},this.apply=(e,t,n)=>{this.xyDerivativeFilter.apply(e,t,n),this.gussianBlurFilter.apply(t.get(),t,n),this.shader.setUniform("flipY",-1),this.shader.setUniform("texelWidth",1/n.w),this.shader.setUniform("texelHeight",1/n.h),this.shader.setUniform("inputImageTexture",t.get());for(const[e,t]of Object.entries(this.param))this.shader.setUniform(""+e,t);t.shader(this.shader),t.rect(0,0,1,1),this.nonMaximumSuppressionFilter.apply(t.get(),t,n)}}}class ie extends oe{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;   \n    uniform sampler2D inputImageTexture;\n\n    uniform float sensitivity;\n \n    const float harrisConstant = 0.04;\n    \n    void main()\n    {\n      vec3 derivativeElements = texture2D(inputImageTexture, vTexCoord).rgb;\n      \n      float derivativeSum = derivativeElements.x + derivativeElements.y;\n      \n      float zElement = (derivativeElements.z * 2.0) - 1.0;\n  \n      float cornerness = (derivativeElements.x * derivativeElements.y - (zElement * zElement)) / (derivativeSum);\n      \n      gl_FragColor = vec4(vec3(cornerness * sensitivity), 1.0);\n    }    \n    "}}class ae extends oe{constructor(){super(),this.fragmentShader="\n    #ifdef GL_ES\n    precision mediump float;\n    #endif\n\n    varying vec2 vTexCoord;   \n    uniform sampler2D inputImageTexture;\n\n    uniform float sensitivity;\n \n    const float harrisConstant = 0.04;\n    \n    void main()\n    {\n      vec3 derivativeElements = texture2D(inputImageTexture, vTexCoord).rgb;\n      \n      float derivativeDifference = derivativeElements.x - derivativeElements.y;\n      \n      float zElement = (derivativeElements.z * 2.0) - 1.0;\n        \n      // R = Ix^2 + Iy^2 - sqrt( (Ix^2 - Iy^2)^2 + 4 * Ixy * Ixy)\n      float cornerness = derivativeElements.x + derivativeElements.y - sqrt(derivativeDifference * derivativeDifference + 4.0 * zElement * zElement);\n \n      gl_FragColor = vec4(vec3(cornerness * sensitivity), 1.0);\n    }    \n    "}}class le extends r.a{constructor(){super(),this.fragmentShader="\n      #define MAX_RADIUS 10\n\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      varying vec2 vTexCoord;\n\n      uniform float fractionalWidthOfPixel;\n      uniform float aspectRatio;\n     \n      void main()\n      {\n          highp vec2 sampleDivisor = vec2(fractionalWidthOfPixel, fractionalWidthOfPixel / aspectRatio);\n          \n          highp vec2 samplePos = vTexCoord - mod(vTexCoord, sampleDivisor) + 0.5 * sampleDivisor;\n          gl_FragColor = texture2D(textureID, samplePos);\n      }\n    "}}class se extends r.a{constructor(){super(),this.fragmentShader="\n      #define MAX_RADIUS 10\n\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      varying vec2 vTexCoord;\n\n      uniform vec2 center;\n      uniform vec2 pixelSize;\n     \n      \n      void main()\n      {\n        vec2 normCoord = 2.0 * vTexCoord - 1.0;\n        vec2 normCenter = 2.0 * center - 1.0;\n        \n        normCoord -= normCenter;\n        \n        float r = length(normCoord); // to polar coords \n        float phi = atan(normCoord.y, normCoord.x); // to polar coords \n        \n        r = r - mod(r, pixelSize.x) + 0.03;\n        phi = phi - mod(phi, pixelSize.y);\n              \n        normCoord.x = r * cos(phi);\n        normCoord.y = r * sin(phi);\n          \n        normCoord += normCenter;\n        \n        mediump vec2 textureCoordinateToUse = normCoord / 2.0 + 0.5;\n        \n        gl_FragColor = texture2D(textureID, textureCoordinateToUse);\n      }\n    "}}class ue extends r.a{constructor(){super(),this.fragmentShader="\n      #define MAX_RADIUS 10\n\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      varying vec2 vTexCoord;\n\n      uniform float fractionalWidthOfPixel;\n      uniform float aspectRatio;\n      uniform float dotScaling;\n      \n      void main()\n      {\n          vec2 sampleDivisor = vec2(fractionalWidthOfPixel, fractionalWidthOfPixel / aspectRatio);\n          \n          vec2 samplePos = vTexCoord - mod(vTexCoord, sampleDivisor) + 0.5 * sampleDivisor;\n          vec2 textureCoordinateToUse = vec2(vTexCoord.x, (vTexCoord.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n          vec2 adjustedSamplePos = vec2(samplePos.x, (samplePos.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n          float distanceFromSamplePoint = distance(adjustedSamplePos, textureCoordinateToUse);\n          float checkForPresenceWithinDot = step(distanceFromSamplePoint, (fractionalWidthOfPixel * 0.5) * dotScaling);\n     \n          vec4 inputColor = texture2D(textureID, samplePos);\n          \n          gl_FragColor = vec4(inputColor.rgb * checkForPresenceWithinDot, inputColor.a);\n      }\n    "}}class ce extends r.a{constructor(){super(),this.fragmentShader="\n      #define MAX_RADIUS 10\n\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      varying vec2 vTexCoord;\n\n      uniform float fractionalWidthOfPixel;\n      uniform float aspectRatio;\n      uniform float dotScaling;\n      \n      const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n\n      void main()\n      {\n          vec2 sampleDivisor = vec2(fractionalWidthOfPixel, fractionalWidthOfPixel / aspectRatio);\n          \n          vec2 samplePos = vTexCoord - mod(vTexCoord, sampleDivisor) + 0.5 * sampleDivisor;\n          vec2 textureCoordinateToUse = vec2(vTexCoord.x, (vTexCoord.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n          vec2 adjustedSamplePos = vec2(samplePos.x, (samplePos.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n          float distanceFromSamplePoint = distance(adjustedSamplePos, textureCoordinateToUse);\n          \n          vec3 sampledColor = texture2D(textureID, samplePos ).rgb;\n          float dotScaling = 1.0 - dot(sampledColor, W);\n         \n          float checkForPresenceWithinDot = 1.0 - step(distanceFromSamplePoint, (fractionalWidthOfPixel * 0.5) * dotScaling);\n          \n          gl_FragColor = vec4(vec3(checkForPresenceWithinDot), 1.0);\n      }\n    "}}class de extends r.a{constructor(){super(),this.fragmentShader="\n      #define MAX_RADIUS 10\n\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      varying vec2 vTexCoord;\n\n      uniform float crossHatchSpacing;\n      uniform float lineWidth;\n      \n      const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n     \n      void main()\n      {\n          float luminance = dot(texture2D(textureID, vTexCoord).rgb, W);\n          \n          vec4 colorToDisplay = vec4(1.0, 1.0, 1.0, 1.0);\n          if (luminance < 1.00) \n          {\n              if (mod(vTexCoord.x + vTexCoord.y, crossHatchSpacing) <= lineWidth) \n              {\n                  colorToDisplay = vec4(0.0, 0.0, 0.0, 1.0);\n              }\n          }\n          if (luminance < 0.75) \n          {\n              if (mod(vTexCoord.x - vTexCoord.y, crossHatchSpacing) <= lineWidth) \n              {\n                  colorToDisplay = vec4(0.0, 0.0, 0.0, 1.0);\n              }\n          }\n          if (luminance < 0.50) \n          {\n              if (mod(vTexCoord.x + vTexCoord.y - (crossHatchSpacing / 2.0), crossHatchSpacing) <= lineWidth) \n              {\n                  colorToDisplay = vec4(0.0, 0.0, 0.0, 1.0);\n              }\n          }\n          if (luminance < 0.3) \n          {\n              if (mod(vTexCoord.x - vTexCoord.y - (crossHatchSpacing / 2.0), crossHatchSpacing) <= lineWidth) \n              {\n                  colorToDisplay = vec4(0.0, 0.0, 0.0, 1.0);\n              }\n          }\n     \n          gl_FragColor = colorToDisplay;\n      }    \n      "}}class xe extends _{constructor(){super(),this.fragmentShader="\n      #define MAX_RADIUS 10\n\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      varying vec2 vTexCoord;\n\n      varying vec2 leftTextureCoordinate;\n      varying vec2 rightTextureCoordinate;\n      \n      varying vec2 topTextureCoordinate;\n      varying vec2 topLeftTextureCoordinate;\n      varying vec2 topRightTextureCoordinate;\n      \n      varying vec2 bottomTextureCoordinate;\n      varying vec2 bottomLeftTextureCoordinate;\n      varying vec2 bottomRightTextureCoordinate;\n      \n      uniform float edgeStrength;\n      \n      void main()\n      {\n          float bottomLeftIntensity = texture2D(textureID, bottomLeftTextureCoordinate).r;\n          float topRightIntensity = texture2D(textureID, topRightTextureCoordinate).r;\n          float topLeftIntensity = texture2D(textureID, topLeftTextureCoordinate).r;\n          float bottomRightIntensity = texture2D(textureID, bottomRightTextureCoordinate).r;\n          float leftIntensity = texture2D(textureID, leftTextureCoordinate).r;\n          float rightIntensity = texture2D(textureID, rightTextureCoordinate).r;\n          float bottomIntensity = texture2D(textureID, bottomTextureCoordinate).r;\n          float topIntensity = texture2D(textureID, topTextureCoordinate).r;\n          float h = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n          float v = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n          \n          float mag = 1.0 - (length(vec2(h, v)) * edgeStrength);\n          \n          gl_FragColor = vec4(vec3(mag), 1.0);\n      }    "}}class me extends _{constructor(){super(),this.fragmentShader="\n      #define MAX_RADIUS 10\n\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      varying vec2 vTexCoord;\n\n      varying vec2 leftTextureCoordinate;\n      varying vec2 rightTextureCoordinate;\n      \n      varying vec2 topTextureCoordinate;\n      varying vec2 topLeftTextureCoordinate;\n      varying vec2 topRightTextureCoordinate;\n      \n      varying vec2 bottomTextureCoordinate;\n      varying vec2 bottomLeftTextureCoordinate;\n      varying vec2 bottomRightTextureCoordinate;\n      \n      uniform float edgeStrength;\n      uniform float threshold;\n      \n      void main()\n      {\n          float bottomLeftIntensity = texture2D(textureID, bottomLeftTextureCoordinate).r;\n          float topRightIntensity = texture2D(textureID, topRightTextureCoordinate).r;\n          float topLeftIntensity = texture2D(textureID, topLeftTextureCoordinate).r;\n          float bottomRightIntensity = texture2D(textureID, bottomRightTextureCoordinate).r;\n          float leftIntensity = texture2D(textureID, leftTextureCoordinate).r;\n          float rightIntensity = texture2D(textureID, rightTextureCoordinate).r;\n          float bottomIntensity = texture2D(textureID, bottomTextureCoordinate).r;\n          float topIntensity = texture2D(textureID, topTextureCoordinate).r;\n          float h = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n          float v = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n          \n          float mag = (length(vec2(h, v)) * edgeStrength);\n          mag = step(threshold, mag);\n          mag = 1.0 - mag;\n          \n          gl_FragColor = vec4(vec3(mag), 1.0);\n      }    "}}class ve extends _{constructor(){super(),this.fragmentShader="\n      #define MAX_RADIUS 10\n\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      varying vec2 vTexCoord;\n\n      varying vec2 leftTextureCoordinate;\n      varying vec2 rightTextureCoordinate;\n      \n      varying vec2 topTextureCoordinate;\n      varying vec2 topLeftTextureCoordinate;\n      varying vec2 topRightTextureCoordinate;\n      \n      varying vec2 bottomTextureCoordinate;\n      varying vec2 bottomLeftTextureCoordinate;\n      varying vec2 bottomRightTextureCoordinate;\n      \n      uniform highp float threshold;\n      uniform highp float quantizationLevels;\n      \n      void main()\n      {\n          vec4 textureColor = texture2D(textureID, vTexCoord);\n\n          float bottomLeftIntensity = texture2D(textureID, bottomLeftTextureCoordinate).r;\n          float topRightIntensity = texture2D(textureID, topRightTextureCoordinate).r;\n          float topLeftIntensity = texture2D(textureID, topLeftTextureCoordinate).r;\n          float bottomRightIntensity = texture2D(textureID, bottomRightTextureCoordinate).r;\n          float leftIntensity = texture2D(textureID, leftTextureCoordinate).r;\n          float rightIntensity = texture2D(textureID, rightTextureCoordinate).r;\n          float bottomIntensity = texture2D(textureID, bottomTextureCoordinate).r;\n          float topIntensity = texture2D(textureID, topTextureCoordinate).r;\n          float h = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n          float v = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n          \n          float mag = length(vec2(h, v));\n\n          vec3 posterizedImageColor = floor((textureColor.rgb * quantizationLevels) + 0.5) / quantizationLevels;\n          \n          float thresholdTest = 1.0 - step(threshold, mag);\n          \n          gl_FragColor = vec4(posterizedImageColor * thresholdTest, textureColor.a);      }    "}}class fe{constructor(){this.gaussianBlurFilter=new A,this.toonFilter=new ve,this.createShader=e=>{this.gaussianBlurFilter.shader=e.createShader(this.gaussianBlurFilter.vertexShader,this.gaussianBlurFilter.fragmentShader),this.gaussianBlurFilter.param={radius:this.param.radius,sigma:this.param.sigma},this.toonFilter.shader=e.createShader(this.toonFilter.vertexShader,this.toonFilter.fragmentShader),this.toonFilter.param={threshold:this.param.threshold,quantizationLevels:this.param.quantizationLevels}},this.apply=(e,t,n)=>{this.gaussianBlurFilter.apply(e,t,n),this.toonFilter.apply(t.get(),t,n)}}}class ge extends r.a{constructor(){super(),this.fragmentShader="\n      #define MAX_RADIUS 10\n\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      varying vec2 vTexCoord;\n\n      uniform float colorLevels;\n \n      void main()\n      {\n          vec4 textureColor = texture2D(textureID, vTexCoord);\n          \n          gl_FragColor = floor((textureColor * colorLevels) + vec4(0.5)) / colorLevels;\n      }     \n      "}}class he extends r.a{constructor(){super(),this.fragmentShader="\n      #define MAX_RADIUS 10\n\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      varying vec2 vTexCoord;\n\n      uniform vec2 center;\n      uniform float radius;\n      uniform float angle;\n      \n      void main()\n      {\n        vec2 textureCoordinateToUse = vTexCoord;\n        float dist = distance(center, vTexCoord);\n        if (dist < radius)\n        {\n            textureCoordinateToUse -= center;\n            float percent = (radius - dist) / radius;\n            float theta = percent * percent * angle * 8.0;\n            float s = sin(theta);\n            float c = cos(theta);\n            textureCoordinateToUse = vec2(dot(textureCoordinateToUse, vec2(c, -s)), dot(textureCoordinateToUse, vec2(s, c)));\n            textureCoordinateToUse += center;\n        }\n        \n        gl_FragColor = texture2D(textureID, textureCoordinateToUse);\n      }\n      "}}class pe extends r.a{constructor(){super(),this.fragmentShader="\n      #define MAX_RADIUS 10\n\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      varying vec2 vTexCoord;\n\n      uniform float aspectRatio;\n      uniform vec2 center;\n      uniform float radius;\n      uniform float scale;\n     \n      void main()\n      {\n         highp vec2 textureCoordinateToUse = vec2(vTexCoord.x, ((vTexCoord.y - center.y) * aspectRatio) + center.y);\n         highp float dist = distance(center, textureCoordinateToUse);\n         textureCoordinateToUse = vTexCoord;\n         \n         if (dist < radius)\n         {\n             textureCoordinateToUse -= center;\n             highp float percent = 1.0 - ((radius - dist) / radius) * scale;\n             percent = percent * percent;\n             \n             textureCoordinateToUse = textureCoordinateToUse * percent;\n             textureCoordinateToUse += center;\n         }\n         \n         gl_FragColor = texture2D(textureID, textureCoordinateToUse );    \n      }\n      "}}class Ce extends r.a{constructor(){super(),this.fragmentShader="\n      #define MAX_RADIUS 10\n\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      varying vec2 vTexCoord;\n\n      uniform float aspectRatio;\n      uniform vec2 center;\n      uniform float radius;\n      uniform float scale;\n     \n      void main()\n      {\n          highp vec2 textureCoordinateToUse = vec2(vTexCoord.x, (vTexCoord.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n          highp float dist = distance(center, textureCoordinateToUse);\n          textureCoordinateToUse = vTexCoord;\n          \n          if (dist < radius)\n          {\n              textureCoordinateToUse -= center;\n              highp float percent = 1.0 + ((0.5 - dist) / 0.5) * scale;\n              textureCoordinateToUse = textureCoordinateToUse * percent;\n              textureCoordinateToUse += center;\n              \n              gl_FragColor = texture2D(textureID, textureCoordinateToUse );\n          }\n          else\n          {\n              gl_FragColor = texture2D(textureID, vTexCoord);\n          }\n      }\n      "}}class be extends r.a{constructor(){super(),this.fragmentShader="\n      #define MAX_RADIUS 10\n\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      varying vec2 vTexCoord;\n\n      uniform vec2 center;\n \n      void main()\n      {\n          highp vec2 normCoord = 2.0 * vTexCoord - 1.0;\n          highp vec2 normCenter = 2.0 * center - 1.0;\n          \n          normCoord -= normCenter;\n          mediump vec2 s = sign(normCoord);\n          normCoord = abs(normCoord);\n          normCoord = 0.5 * normCoord + 0.5 * smoothstep(0.25, 0.5, normCoord) * normCoord;\n          normCoord = s * normCoord;\n          \n          normCoord += normCenter;\n             \n          mediump vec2 textureCoordinateToUse = normCoord / 2.0 + 0.5;\n          \n          \n          gl_FragColor = texture2D(textureID, textureCoordinateToUse);\n          \n      }\n      "}}class De extends r.a{constructor(){super(),this.fragmentShader="\n      #define MAX_RADIUS 10\n\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      varying vec2 vTexCoord;\n\n      uniform vec2 center;\n      uniform float radius;\n      uniform float aspectRatio;\n      uniform float refractiveIndex;\n      \n      void main()\n      {\n          vec2 textureCoordinateToUse = vec2(vTexCoord.x, (-vTexCoord.y * aspectRatio + 0.5 + 0.5 * aspectRatio));\n          float distanceFromCenter = distance(center, textureCoordinateToUse);\n          float checkForPresenceWithinSphere = step(distanceFromCenter, radius);\n          \n          distanceFromCenter = distanceFromCenter / radius;\n          \n          float normalizedDepth = radius * sqrt(1.0 - distanceFromCenter * distanceFromCenter);\n          vec3 sphereNormal = normalize(vec3(textureCoordinateToUse - center, normalizedDepth));\n          \n          vec3 refractedVector = refract(vec3(0.0, 0.0, -1.0), sphereNormal, refractiveIndex);\n          refractedVector.x = -refractedVector.x;\n          \n          gl_FragColor = texture2D(textureID, (refractedVector.xy + 1.0) * 0.5) * checkForPresenceWithinSphere;    \n      }\n      "}}class ye extends r.a{constructor(){super(),this.fragmentShader="\n      #define MAX_RADIUS 10\n\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      varying vec2 vTexCoord;\n\n      uniform vec2 center;\n      uniform float radius;\n      uniform float aspectRatio;\n      uniform float refractiveIndex;\n\n      const highp vec3 lightPosition = vec3(-0.5, 0.5, 1.0);\n      const highp vec3 ambientLightPosition = vec3(0.0, 0.0, 1.0);\n      \n      void main()\n      {\n        highp vec2 textureCoordinateToUse = vec2(vTexCoord.x, (vTexCoord.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n        highp float distanceFromCenter = distance(center, textureCoordinateToUse);\n        lowp float checkForPresenceWithinSphere = step(distanceFromCenter, radius);\n        \n        distanceFromCenter = distanceFromCenter / radius;\n        \n        float normalizedDepth = radius * sqrt(1.0 - distanceFromCenter * distanceFromCenter);\n        vec3 sphereNormal = normalize(vec3(textureCoordinateToUse - center, normalizedDepth));\n        \n        vec3 refractedVector = 2.0 * refract(vec3(0.0, 0.0, -1.0), sphereNormal, refractiveIndex);\n        refractedVector.xy = -refractedVector.xy;\n        \n        vec3 finalSphereColor = texture2D(textureID, (refractedVector.xy + 1.0) * 0.5).rgb;\n        \n        // Grazing angle lighting\n        highp float lightingIntensity = 2.5 * (1.0 - pow(clamp(dot(ambientLightPosition, sphereNormal), 0.0, 1.0), 0.25));\n        finalSphereColor += lightingIntensity;\n        \n        // Specular lighting\n        lightingIntensity  = clamp(dot(normalize(lightPosition), sphereNormal), 0.0, 1.0);\n        lightingIntensity  = pow(lightingIntensity, 15.0);\n        finalSphereColor += vec3(0.8, 0.8, 0.8) * lightingIntensity;\n        \n        gl_FragColor = vec4(finalSphereColor, 1.0) * checkForPresenceWithinSphere;\n      }\n      "}}class Te extends r.a{constructor(){super(),this.fragmentShader="\n      #define MAX_RADIUS 10\n\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      varying vec2 vTexCoord;\n\n      uniform vec2 vignetteCenter;\n      uniform vec3 vignetteColor;\n      uniform float vignetteStart;\n      uniform float vignetteEnd;\n      \n      void main()\n      {\n          vec4 sourceImageColor = texture2D(textureID, vTexCoord);\n          float d = distance(vTexCoord, vec2(vignetteCenter.x, vignetteCenter.y));\n          float percent = smoothstep(vignetteStart, vignetteEnd, d);\n          gl_FragColor = vec4(mix(sourceImageColor.rgb, vignetteColor, percent), sourceImageColor.a);\n      }\n      "}}class Ie extends r.a{constructor(){super(),this.fragmentShader="\n      #define MAX_RADIUS 10\n\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      varying vec2 vTexCoord;\n\n      uniform int radius;\n      \n      const vec2 src_size = vec2 (1.0 / 768.0, 1.0 / 1024.0);\n      \n      void main() \n      {\n          vec2 uv = vTexCoord;\n          float n = float((radius + 1) * (radius + 1));\n          vec3 m0 = vec3(0.0); vec3 m1 = vec3(0.0); vec3 m2 = vec3(0.0); vec3 m3 = vec3(0.0);\n          vec3 s0 = vec3(0.0); vec3 s1 = vec3(0.0); vec3 s2 = vec3(0.0); vec3 s3 = vec3(0.0);\n          vec3 c;\n     \n          for (int j = -MAX_RADIUS; j <= 0; ++j)  {\n              if (float(radius)+0.1 <= abs(float(j))) continue;\n              for (int i = -MAX_RADIUS; i <= 0; ++i)  {\n                  if (float(radius)+0.1 <= abs(float(i))) continue;\n                  c = texture2D(textureID, uv + vec2(i,j) * src_size).rgb;\n                  m0 += c;\n                  s0 += c * c;\n              }\n          }\n     \n          for (int j = -MAX_RADIUS; j <= 0; ++j)  {\n              if (float(radius)+0.1 <= abs(float(j))) continue;\n              for (int i = 0; i <= MAX_RADIUS; ++i)  {\n                  if (float(radius)-0.1 <= abs(float(i))) break;\n                  c = texture2D(textureID, uv + vec2(i,j) * src_size).rgb;\n                  m1 += c;\n                  s1 += c * c;\n              }\n          }\n     \n          for (int j = 0; j <= MAX_RADIUS; ++j)  {\n              if (float(radius)-0.1 <= abs(float(j))) break;\n              for (int i = 0; i <= MAX_RADIUS; ++i)  {\n                  if (float(radius)-0.1 <= abs(float(i))) break;\n                  c = texture2D(textureID, uv + vec2(i,j) * src_size).rgb;\n                  m2 += c;\n                  s2 += c * c;\n              }\n          }\n     \n          for (int j = 0; j <= MAX_RADIUS; ++j)  {\n              if (float(radius)-0.1 <= abs(float(j))) break;\n              for (int i = -MAX_RADIUS; i <= 0; ++i)  {\n                  if (float(radius)+0.1 <= abs(float(i))) continue;\n                  c = texture2D(textureID, uv + vec2(i,j) * src_size).rgb;\n                  m3 += c;\n                  s3 += c * c;\n              }\n          }\n     \n     \n          float min_sigma2 = 1e+2;\n          m0 /= n;\n          s0 = abs(s0 / n - m0 * m0);\n     \n          float sigma2 = s0.r + s0.g + s0.b;\n          if (sigma2 < min_sigma2) {\n              min_sigma2 = sigma2;\n              gl_FragColor = vec4(m0, 1.0);\n          }\n     \n          m1 /= n;\n          s1 = abs(s1 / n - m1 * m1);\n     \n          sigma2 = s1.r + s1.g + s1.b;\n          if (sigma2 < min_sigma2) {\n              min_sigma2 = sigma2;\n              gl_FragColor = vec4(m1, 1.0);\n          }\n     \n          m2 /= n;\n          s2 = abs(s2 / n - m2 * m2);\n     \n          sigma2 = s2.r + s2.g + s2.b;\n          if (sigma2 < min_sigma2) {\n              min_sigma2 = sigma2;\n              gl_FragColor = vec4(m2, 1.0);\n          }\n     \n          m3 /= n;\n          s3 = abs(s3 / n - m3 * m3);\n     \n          sigma2 = s3.r + s3.g + s3.b;\n          if (sigma2 < min_sigma2) {\n              min_sigma2 = sigma2;\n              gl_FragColor = vec4(m3, 1.0);\n          }\n      }      \n      "}}class Se extends r.a{constructor(){super(),this.fragmentShader="\n      #define MAX_RADIUS 10\n\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      varying vec2 vTexCoord;\n\n      void main()\n      {\n          vec2 sampleDivisor = vec2(1.0 / 200.0, 1.0 / 320.0);\n          \n          vec2 samplePos = vTexCoord - mod(vTexCoord, sampleDivisor);\n          vec4 color = texture2D(textureID, samplePos );\n          \n          vec4 colorCyan = vec4(85.0 / 255.0, 1.0, 1.0, 1.0);\n          vec4 colorMagenta = vec4(1.0, 85.0 / 255.0, 1.0, 1.0);\n          vec4 colorWhite = vec4(1.0, 1.0, 1.0, 1.0);\n          vec4 colorBlack = vec4(0.0, 0.0, 0.0, 1.0);\n          \n          float blackDistance = distance(color, colorBlack);\n          float whiteDistance = distance(color, colorWhite);\n          float magentaDistance = distance(color, colorMagenta);\n          float cyanDistance = distance(color, colorCyan);\n          \n          vec4 finalColor;\n          \n          float colorDistance = min(magentaDistance, cyanDistance);\n          colorDistance = min(colorDistance, whiteDistance);\n          colorDistance = min(colorDistance, blackDistance); \n          \n          if (colorDistance == blackDistance) {\n              finalColor = colorBlack;\n          } else if (colorDistance == whiteDistance) {\n              finalColor = colorWhite;\n          } else if (colorDistance == cyanDistance) {\n              finalColor = colorCyan;\n          } else {\n              finalColor = colorMagenta;\n          }\n          \n          gl_FragColor = finalColor;\n      }      "}}class Fe extends r.a{constructor(){super(),this.fragmentShader="\n      #define MAX_RADIUS 10\n\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n\n      uniform sampler2D textureID;\n      varying vec2 vTexCoord;\n\n      uniform float threshold;\n \n      const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n      \n      void main()\n      {\n          highp vec4 textureColor = texture2D(textureID, vTexCoord);\n          highp float luminance = dot(textureColor.rgb, W);\n          highp float thresholdResult = step(luminance, threshold);\n          highp vec3 finalColor = abs(thresholdResult - textureColor.rgb);\n          \n          gl_FragColor = vec4(finalColor, textureColor.w);\n      }      "}}var _e=n(1);class we extends HTMLElement{static get observedAttributes(){return["src","filters","width","height"]}attributeChangedCallback(e,t,n){switch(console.log(e+" "+t+" "+n),e){case"src":case"filters":break;case"width":console.log(`width changed from ${t} to ${n}`);break;case"height":console.log(`height changed from ${t} to ${n}`)}}constructor(){console.log("p5img constructor"),super(),console.log(this.src),console.log(this.filters),console.log(this.height),this.p5Image=new _e.a(this)}get src(){return this.getAttribute("src")}set src(e){this.setAttribute("src",e)}get filters(){return this.getAttribute("filters")}set filters(e){this.setAttribute("filters",e)}get width(){return this.getAttribute("width")}set width(e){this.setAttribute("width",e)}get height(){return this.getAttribute("height")}set height(e){this.setAttribute("height",e)}}customElements.define("p5-img",we);class Le{constructor(){this.vertexShader="\n      #ifdef GL_ES\n      precision mediump float;\n      #endif\n  \n      attribute vec3 aPosition;\n      attribute vec2 aTexCoord;\n      uniform float flipY;\n      varying vec2 vTexCoord;\n      \n      void main() {\n        vec4 positionVec4 = vec4(aPosition * vec3(1.0, flipY, 1.0), 1.0);\n        positionVec4.xy = positionVec4.xy * 2.0 + vec2(-1.0, 1.0);\n        gl_Position = positionVec4;\n        vTexCoord = aTexCoord;\n      }\n      ",this.fragmentShader="\n      #ifdef GL_ES\n        precision mediump float;\n      #endif\n        \n      varying vec2 vTexCoord;\n      uniform sampler2D textureID1;\n      uniform sampler2D textureID2;\n  \n      void main() {\n        gl_FragColor = texture2D(textureID1, vTexCoord)*0.5 + texture2D(textureID2, vTexCoord)*0.5;\n      }\n      ",this.createShader=e=>{this.shader=e.createShader(this.vertexShader,this.fragmentShader)},this.apply=(e,t,n)=>{this.shader.setUniform("flipY",-1),this.shader.setUniform("textureID1",t),this.shader.setUniform("textureID2",n);for(const[e,t]of Object.entries(this.param))this.shader.setUniform(""+e,t);e.shader(this.shader),e.rect(0,0,1,1)}}}class Re extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n\n\n        void main()\n        {\n            vec4 base = texture2D(textureID1, vTexCoord);\n            vec4 overlay = texture2D(textureID2, vTexCoord);\n            \n            float r;\n            if (overlay.r * base.a + base.r * overlay.a >= overlay.a * base.a) {\n                r = overlay.a * base.a + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n            } else {\n                r = overlay.r + base.r;\n            }\n        \n            float g;\n            if (overlay.g * base.a + base.g * overlay.a >= overlay.a * base.a) {\n                g = overlay.a * base.a + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n            } else {\n                g = overlay.g + base.g;\n            }\n        \n            float b;\n            if (overlay.b * base.a + base.b * overlay.a >= overlay.a * base.a) {\n                b = overlay.a * base.a + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n            } else {\n                b = overlay.b + base.b;\n            }\n        \n            float a = overlay.a + base.a - overlay.a * base.a;\n            \n            gl_FragColor = vec4(r, g, b, a);\n        }"}}class Pe extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n\n        void main()\n        {\n            vec4 base = texture2D(textureID1, vTexCoord);\n            vec4 overlayer = texture2D(textureID2, vTexCoord);\n                \n            gl_FragColor = overlayer * base + overlayer * (1.0 - base.a) + base * (1.0 - overlayer.a);\n        }\n        "}}class We extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n\n        uniform float thresholdSensitivity;\n        uniform float smoothing;\n        uniform vec3 colorToReplace;\n        \n        void main()\n        {\n            vec4 textureColor = texture2D(textureID1, vTexCoord);\n            vec4 textureColor2 = texture2D(textureID2, vTexCoord);\n            \n            float maskY = 0.2989 * colorToReplace.r + 0.5866 * colorToReplace.g + 0.1145 * colorToReplace.b;\n            float maskCr = 0.7132 * (colorToReplace.r - maskY);\n            float maskCb = 0.5647 * (colorToReplace.b - maskY);\n            \n            float Y = 0.2989 * textureColor2.r + 0.5866 * textureColor2.g + 0.1145 * textureColor2.b;\n            float Cr = 0.7132 * (textureColor2.r - Y);\n            float Cb = 0.5647 * (textureColor2.b - Y);\n            \n       //     float blendValue = 1.0 - smoothstep(thresholdSensitivity - smoothing, thresholdSensitivity , abs(Cr - maskCr) + abs(Cb - maskCb));\n            float blendValue = smoothstep(thresholdSensitivity, thresholdSensitivity + smoothing, distance(vec2(Cr, Cb), vec2(maskCr, maskCb)));\n            gl_FragColor = mix(textureColor, textureColor2, blendValue);\n        }        "}}class Ee extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n\n\n        void main()\n        {\n            lowp vec4 textureColor = texture2D(textureID1, vTexCoord);\n            lowp vec4 textureColor2 = texture2D(textureID2, vTexCoord);\n            \n            gl_FragColor = vec4(textureColor.rgb - textureColor2.rgb, textureColor.a);\n        }\n        "}}class Ge extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n\n\n        void main()\n        {\n            vec4 base = texture2D(textureID1, vTexCoord);\n            vec4 overlay = texture2D(textureID2, vTexCoord);\n          \n          float ra;\n          if (overlay.a == 0.0 || ((base.r / overlay.r) > (base.a / overlay.a)))\n            ra = overlay.a * base.a + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n          else\n            ra = (base.r * overlay.a * overlay.a) / overlay.r + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n          \n       \n          mediump float ga;\n          if (overlay.a == 0.0 || ((base.g / overlay.g) > (base.a / overlay.a)))\n            ga = overlay.a * base.a + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n          else\n            ga = (base.g * overlay.a * overlay.a) / overlay.g + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n       \n          \n          mediump float ba;\n          if (overlay.a == 0.0 || ((base.b / overlay.b) > (base.a / overlay.a)))\n            ba = overlay.a * base.a + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n          else\n            ba = (base.b * overlay.a * overlay.a) / overlay.b + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n       \n          mediump float a = overlay.a + base.a - overlay.a * base.a;\n          \n            gl_FragColor = vec4(ra, ga, ba, a);\n        }\n        "}}class Ae extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n\n\n        void main()\n        {\n            vec4 base = texture2D(textureID1, vTexCoord);\n            vec4 overlay = texture2D(textureID2, vTexCoord);\n            \n            float ra;\n            if (2.0 * base.r < base.a) {\n                ra = 2.0 * overlay.r * base.r + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n            } else {\n                ra = overlay.a * base.a - 2.0 * (base.a - base.r) * (overlay.a - overlay.r) + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n            }\n            \n            float ga;\n            if (2.0 * base.g < base.a) {\n                ga = 2.0 * overlay.g * base.g + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n            } else {\n                ga = overlay.a * base.a - 2.0 * (base.a - base.g) * (overlay.a - overlay.g) + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n            }\n            \n            float ba;\n            if (2.0 * base.b < base.a) {\n                ba = 2.0 * overlay.b * base.b + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n            } else {\n                ba = overlay.a * base.a - 2.0 * (base.a - base.b) * (overlay.a - overlay.b) + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n            }\n            \n            gl_FragColor = vec4(ra, ga, ba, 1.0);\n        }\n        "}}class Be extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n\n\n        void main()\n        {\n           vec4 base = texture2D(textureID1, vTexCoord);\n           vec4 overlayer = texture2D(textureID2, vTexCoord);\n           \n           gl_FragColor = vec4(min(overlayer.rgb * base.a, base.rgb * overlayer.a) + overlayer.rgb * (1.0 - base.a) + base.rgb * (1.0 - overlayer.a), 1.0);\n        }\n        "}}class ke extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n\n\n        void main()\n        {\n           vec4 base = texture2D(textureID1, vTexCoord);\n           vec4 overlay = texture2D(textureID2, vTexCoord);\n           \n           gl_FragColor = max(base, overlay);\n        }\n        "}}class Me extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n\n\n        void main()\n        {\n           vec4 base = texture2D(textureID1, vTexCoord);\n           vec4 overlay = texture2D(textureID2, vTexCoord);\n           \n           vec4 whiteColor = vec4(1.0);\n           gl_FragColor = whiteColor - (whiteColor - base) / overlay;\n        }\n        "}}class Ue extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n\n\n        void main()\n        {\n           vec4 base = texture2D(textureID1, vTexCoord);\n           vec4 overlay = texture2D(textureID2, vTexCoord);\n           \n           vec3 baseOverlayAlphaProduct = vec3(overlay.a * base.a);\n           vec3 rightHandProduct = overlay.rgb * (1.0 - base.a) + base.rgb * (1.0 - overlay.a);\n           \n           vec3 firstBlendColor = baseOverlayAlphaProduct + rightHandProduct;\n           vec3 overlayRGB = clamp((overlay.rgb / clamp(overlay.a, 0.01, 1.0)) * step(0.0, overlay.a), 0.0, 0.99);\n           \n           vec3 secondBlendColor = (base.rgb * overlay.a) / (1.0 - overlayRGB) + rightHandProduct;\n           \n           vec3 colorChoice = step((overlay.rgb * base.a + base.rgb * overlay.a), baseOverlayAlphaProduct);\n           \n           gl_FragColor = vec4(mix(firstBlendColor, secondBlendColor, colorChoice), 1.0);\n        }\n        "}}class ze extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n\n\n        void main()\n        {\n           vec4 base = texture2D(textureID1, vTexCoord);\n           vec4 overlay = texture2D(textureID2, vTexCoord);\n           \n           mediump vec4 whiteColor = vec4(1.0);\n           gl_FragColor = whiteColor - ((whiteColor - overlay) * (whiteColor - base));\n        }\n        "}}class He extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n\n\n        void main()\n        {\n           vec4 base = texture2D(textureID1, vTexCoord);\n           vec4 overlay = texture2D(textureID2, vTexCoord);\n           //Dca = (Sca.Da + Dca.Sa - 2.Sca.Dca) + Sca.(1 - Da) + Dca.(1 - Sa)\n           gl_FragColor = vec4((overlay.rgb * base.a + base.rgb * overlay.a - 2.0 * overlay.rgb * base.rgb) + overlay.rgb * (1.0 - base.a) + base.rgb * (1.0 - overlay.a), base.a);\n        }\n        "}}class Oe extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n\n\n        void main()\n        {\n            lowp vec4 textureColor = texture2D(textureID1, vTexCoord);\n            lowp vec4 textureColor2 = texture2D(textureID2, vTexCoord);\n            \n            gl_FragColor = vec4(abs(textureColor.rgb - textureColor2.rgb), textureColor.a);\n        }\n        "}}class je extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n\n\n        void main()\n        {\n           vec4 base = texture2D(textureID1, vTexCoord);\n           vec4 overlay = texture2D(textureID2, vTexCoord);\n           \n           float ra;\n           if (2.0 * overlay.r < overlay.a) {\n               ra = 2.0 * overlay.r * base.r + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n           } else {\n               ra = overlay.a * base.a - 2.0 * (base.a - base.r) * (overlay.a - overlay.r) + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n           }\n           \n           float ga;\n           if (2.0 * overlay.g < overlay.a) {\n               ga = 2.0 * overlay.g * base.g + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n           } else {\n               ga = overlay.a * base.a - 2.0 * (base.a - base.g) * (overlay.a - overlay.g) + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n           }\n           \n           float ba;\n           if (2.0 * overlay.b < overlay.a) {\n               ba = 2.0 * overlay.b * base.b + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n           } else {\n               ba = overlay.a * base.a - 2.0 * (base.a - base.b) * (overlay.a - overlay.b) + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n           }\n           \n           gl_FragColor = vec4(ra, ga, ba, 1.0);        \n        }\n        "}}class Ve extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n\n\n        void main()\n        {\n           vec4 base = texture2D(textureID1, vTexCoord);\n           vec4 overlay = texture2D(textureID2, vTexCoord);\n           \n           float alphaDivisor = base.a + step(base.a, 0.0); // Protect against a divide-by-zero blacking out things in the output\n           gl_FragColor = base * (overlay.a * (base / alphaDivisor) + (2.0 * overlay * (1.0 - (base / alphaDivisor)))) + overlay * (1.0 - base.a) + base * (1.0 - overlay.a);\n        }\n        "}}class Ye extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n        uniform lowp float mixturePercent;\n\n        void main()\n        {\n           vec4 textureColor = texture2D(textureID1, vTexCoord);\n           vec4 textureColor2 = texture2D(textureID2, vTexCoord);\n           \n           gl_FragColor = vec4(mix(textureColor.rgb, textureColor2.rgb, textureColor2.a * mixturePercent), textureColor.a);        }\n        "}}class Ne extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n\n\n        void main()\n        {\n            vec4 textureColor = texture2D(textureID1, vTexCoord);\n            vec4 textureColor2 = texture2D(textureID2, vTexCoord);\n            \n            gl_FragColor = mix(textureColor, textureColor2, textureColor2.a);\n        }\n        "}}class Xe extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n\n\n        void main()\n        {\n            vec4 c2 = texture2D(textureID1, vTexCoord);\n            vec4 c1 = texture2D(textureID2, vTexCoord);\n            \n            vec4 outputColor;\n                      \n            float a = c1.a + c2.a * (1.0 - c1.a);\n            float alphaDivisor = a + step(a, 0.0); // Protect against a divide-by-zero blacking out things in the output\n            \n            outputColor.r = (c1.r * c1.a + c2.r * c2.a * (1.0 - c1.a))/alphaDivisor;\n            outputColor.g = (c1.g * c1.a + c2.g * c2.a * (1.0 - c1.a))/alphaDivisor;\n            outputColor.b = (c1.b * c1.a + c2.b * c2.a * (1.0 - c1.a))/alphaDivisor;\n            outputColor.a = a;\n    \n            gl_FragColor = outputColor;\n        }\n        "}}class Qe extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n\n\n        highp float lum(lowp vec3 c) {\n            return dot(c, vec3(0.3, 0.59, 0.11));\n        }\n        \n        lowp vec3 clipcolor(lowp vec3 c) {\n            highp float l = lum(c);\n            lowp float n = min(min(c.r, c.g), c.b);\n            lowp float x = max(max(c.r, c.g), c.b);\n            \n            if (n < 0.0) {\n                c.r = l + ((c.r - l) * l) / (l - n);\n                c.g = l + ((c.g - l) * l) / (l - n);\n                c.b = l + ((c.b - l) * l) / (l - n);\n            }\n            if (x > 1.0) {\n                c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n                c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n                c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n            }\n            \n            return c;\n        }\n       \n        lowp vec3 setlum(lowp vec3 c, highp float l) {\n            highp float d = l - lum(c);\n            c = c + vec3(d);\n            return clipcolor(c);\n        }\n        \n        void main()\n        {\n            highp vec4 baseColor = texture2D(textureID1, vTexCoord);\n            highp vec4 overlayColor = texture2D(textureID2, vTexCoord);\n       \n            gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(overlayColor.rgb, lum(baseColor.rgb)) * overlayColor.a, baseColor.a);\n        }\n        "}}class qe extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n\n        highp float lum(lowp vec3 c) {\n            return dot(c, vec3(0.3, 0.59, 0.11));\n        }\n        \n        lowp vec3 clipcolor(lowp vec3 c) {\n            highp float l = lum(c);\n            lowp float n = min(min(c.r, c.g), c.b);\n            lowp float x = max(max(c.r, c.g), c.b);\n            \n            if (n < 0.0) {\n                c.r = l + ((c.r - l) * l) / (l - n);\n                c.g = l + ((c.g - l) * l) / (l - n);\n                c.b = l + ((c.b - l) * l) / (l - n);\n            }\n            if (x > 1.0) {\n                c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n                c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n                c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n            }\n            \n            return c;\n        }\n        \n        lowp vec3 setlum(lowp vec3 c, highp float l) {\n            highp float d = l - lum(c);\n            c = c + vec3(d);\n            return clipcolor(c);\n        }\n        \n        highp float sat(lowp vec3 c) {\n            lowp float n = min(min(c.r, c.g), c.b);\n            lowp float x = max(max(c.r, c.g), c.b);\n            return x - n;\n        }\n        \n        lowp float mid(lowp float cmin, lowp float cmid, lowp float cmax, highp float s) {\n            return ((cmid - cmin) * s) / (cmax - cmin);\n        }\n        \n        lowp vec3 setsat(lowp vec3 c, highp float s) {\n            if (c.r > c.g) {\n                if (c.r > c.b) {\n                    if (c.g > c.b) {\n                        /* g is mid, b is min */\n                        c.g = mid(c.b, c.g, c.r, s);\n                        c.b = 0.0;\n                    } else {\n                        /* b is mid, g is min */\n                        c.b = mid(c.g, c.b, c.r, s);\n                        c.g = 0.0;\n                    }\n                    c.r = s;\n                } else {\n                    /* b is max, r is mid, g is min */\n                    c.r = mid(c.g, c.r, c.b, s);\n                    c.b = s;\n                    c.r = 0.0;\n                }\n            } else if (c.r > c.b) {\n                /* g is max, r is mid, b is min */\n                c.r = mid(c.b, c.r, c.g, s);\n                c.g = s;\n                c.b = 0.0;\n            } else if (c.g > c.b) {\n                /* g is max, b is mid, r is min */\n                c.b = mid(c.r, c.b, c.g, s);\n                c.g = s;\n                c.r = 0.0;\n            } else if (c.b > c.g) {\n                /* b is max, g is mid, r is min */\n                c.g = mid(c.r, c.g, c.b, s);\n                c.b = s;\n                c.r = 0.0;\n            } else {\n                c = vec3(0.0);\n            }\n            return c;\n        }\n        \n        void main()\n        {\n            highp vec4 baseColor = texture2D(textureID1, vTexCoord);\n            highp vec4 overlayColor = texture2D(textureID2, vTexCoord);\n            \n            gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(setsat(overlayColor.rgb, sat(baseColor.rgb)), lum(baseColor.rgb)) * overlayColor.a, baseColor.a);\n        }\n        "}}class $e extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n\n        highp float lum(lowp vec3 c) {\n            return dot(c, vec3(0.3, 0.59, 0.11));\n        }\n        \n        lowp vec3 clipcolor(lowp vec3 c) {\n            highp float l = lum(c);\n            lowp float n = min(min(c.r, c.g), c.b);\n            lowp float x = max(max(c.r, c.g), c.b);\n            \n            if (n < 0.0) {\n                c.r = l + ((c.r - l) * l) / (l - n);\n                c.g = l + ((c.g - l) * l) / (l - n);\n                c.b = l + ((c.b - l) * l) / (l - n);\n            }\n            if (x > 1.0) {\n                c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n                c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n                c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n            }\n            \n            return c;\n        }\n        \n        lowp vec3 setlum(lowp vec3 c, highp float l) {\n            highp float d = l - lum(c);\n            c = c + vec3(d);\n            return clipcolor(c);\n        }\n        \n        highp float sat(lowp vec3 c) {\n            lowp float n = min(min(c.r, c.g), c.b);\n            lowp float x = max(max(c.r, c.g), c.b);\n            return x - n;\n        }\n        \n        lowp float mid(lowp float cmin, lowp float cmid, lowp float cmax, highp float s) {\n            return ((cmid - cmin) * s) / (cmax - cmin);\n        }\n        \n        lowp vec3 setsat(lowp vec3 c, highp float s) {\n            if (c.r > c.g) {\n                if (c.r > c.b) {\n                    if (c.g > c.b) {\n                        /* g is mid, b is min */\n                        c.g = mid(c.b, c.g, c.r, s);\n                        c.b = 0.0;\n                    } else {\n                        /* b is mid, g is min */\n                        c.b = mid(c.g, c.b, c.r, s);\n                        c.g = 0.0;\n                    }\n                    c.r = s;\n                } else {\n                    /* b is max, r is mid, g is min */\n                    c.r = mid(c.g, c.r, c.b, s);\n                    c.b = s;\n                    c.r = 0.0;\n                }\n            } else if (c.r > c.b) {\n                /* g is max, r is mid, b is min */\n                c.r = mid(c.b, c.r, c.g, s);\n                c.g = s;\n                c.b = 0.0;\n            } else if (c.g > c.b) {\n                /* g is max, b is mid, r is min */\n                c.b = mid(c.r, c.b, c.g, s);\n                c.g = s;\n                c.r = 0.0;\n            } else if (c.b > c.g) {\n                /* b is max, g is mid, r is min */\n                c.g = mid(c.r, c.g, c.b, s);\n                c.b = s;\n                c.r = 0.0;\n            } else {\n                c = vec3(0.0);\n            }\n            return c;\n        }\n        \n        void main()\n        {\n            highp vec4 baseColor = texture2D(textureID1, vTexCoord);\n            highp vec4 overlayColor = texture2D(textureID2, vTexCoord);\n            \n            gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(setsat(baseColor.rgb, sat(overlayColor.rgb)), lum(baseColor.rgb)) * overlayColor.a, baseColor.a);\n        }\n        "}}class Ke extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n\n        highp float lum(lowp vec3 c) {\n            return dot(c, vec3(0.3, 0.59, 0.11));\n        }\n        \n        lowp vec3 clipcolor(lowp vec3 c) {\n            highp float l = lum(c);\n            lowp float n = min(min(c.r, c.g), c.b);\n            lowp float x = max(max(c.r, c.g), c.b);\n            \n            if (n < 0.0) {\n                c.r = l + ((c.r - l) * l) / (l - n);\n                c.g = l + ((c.g - l) * l) / (l - n);\n                c.b = l + ((c.b - l) * l) / (l - n);\n            }\n            if (x > 1.0) {\n                c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n                c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n                c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n            }\n            \n            return c;\n        }\n        \n        lowp vec3 setlum(lowp vec3 c, highp float l) {\n            highp float d = l - lum(c);\n            c = c + vec3(d);\n            return clipcolor(c);\n        }\n        \n        void main()\n        {\n            highp vec4 baseColor = texture2D(textureID1, vTexCoord);\n            highp vec4 overlayColor = texture2D(textureID2, vTexCoord);\n            \n            gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(baseColor.rgb, lum(overlayColor.rgb)) * overlayColor.a, baseColor.a);\n        }\n        "}}class Je extends Le{constructor(){super(),this.fragmentShader="\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        \n        varying vec2 vTexCoord;\n        uniform sampler2D textureID1;\n        uniform sampler2D textureID2;\n\n\n        void main()\n        {\n            lowp vec4 textureColor = texture2D(textureID1, vTexCoord);\n            lowp vec4 textureColor2 = texture2D(textureID2, vTexCoord);\n            \n            gl_FragColor = vec4(clamp(textureColor.rgb + textureColor2.rgb - vec3(1.0), vec3(0.0), vec3(1.0)), textureColor.a);\n        }\n        "}}var Ze=n(2);class et extends HTMLElement{static get observedAttributes(){return["src1","src2","mode","param","width","height"]}attributeChangedCallback(e,t,n){switch(console.log(e+" "+t+" "+n),e){case"src1":case"src2":case"mode":case"param":break;case"width":console.log(`width changed from ${t} to ${n}`);break;case"height":console.log(`height changed from ${t} to ${n}`)}}constructor(){console.log("p5imgblendElement constructor"),super(),this.p5ImageBlend=new Ze.a(this)}get src1(){return this.getAttribute("src1")}set src1(e){this.setAttribute("src1",e)}get src2(){return this.getAttribute("src2")}set src2(e){this.setAttribute("src2",e)}get mode(){return this.getAttribute("mode")}set mode(e){this.setAttribute("mode",e)}get param(){return this.getAttribute("param")}set param(e){this.setAttribute("param",e)}get width(){return this.getAttribute("width")}set width(e){this.setAttribute("width",e)}get height(){return this.getAttribute("height")}set height(e){this.setAttribute("height",e)}}customElements.define("p5-img-blend",et)}])}));